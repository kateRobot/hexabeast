////////////////////////////////////////////////////////////////////////////////
// SoftKinetic DepthSense SDK
//
// COPYRIGHT AND CONFIDENTIALITY NOTICE - SOFTKINETIC CONFIDENTIAL
// INFORMATION
//
// All rights reserved to SOFTKINETIC SENSORS NV (a
// company incorporated and existing under the laws of Belgium, with
// its principal place of business at Boulevard de la Plainelaan 11,
// 1050 Brussels (Belgium), registered with the Crossroads bank for
// enterprises under company number 0811 341 454 - "Softkinetic
// Sensors").
//
// The source code of the SoftKinetic DepthSense Camera Drivers is
// proprietary and confidential information of Softkinetic Sensors NV.
//
// For any question about terms and conditions, please contact:
// info@softkinetic.com Copyright (c) 2002-2015 Softkinetic Sensors NV
////////////////////////////////////////////////////////////////////////////////

// automatically generated by dsic, do not edit
#ifndef _DEPTHSENSE_PUBLIC_HXX
#define _DEPTHSENSE_PUBLIC_HXX
/// The DepthSense Software Development Kit
namespace DepthSense
{
    class Interface;
    class AudioNode;
    class ColorNode;
    class DepthNode;
    class UnsupportedNode;
    class Context;
    class Device;
    class Node;
    namespace Audio
    {
        class SampleData;
    };
    namespace Color
    {
        class SampleData;
    };
    namespace Depth
    {
        class IMUData;
        class SampleData;
        class ButtonEventData;
    };
};
#include <vector>
#include <string>
#include <functional>
#include <DepthSenseAPI.h>
#include <Pointer.hxx>
#include <String.hxx>
#include <Vector.hxx>
#include <Type.hxx>
#include <Event.hxx>
namespace DSI
{
    class Client;
    class Marshalling;
    class CMarshalling;
}
namespace DepthSense
{
    namespace Utils
    {
        class BinaryReader;
    }
}
namespace DepthSense
{
    /// The image resolution
    ///   
    /// A type enumerating the various frame formats supported by
    /// DepthSense SDK.
    enum FrameFormat
    {
        FRAME_FORMAT_UNKNOWN = 0,/*!< unknown */
        FRAME_FORMAT_QQVGA = 1,/*!< QQVGA (160x120) */
        FRAME_FORMAT_QCIF = 2,/*!< QCIF (176x144) */
        FRAME_FORMAT_HQVGA = 3,/*!< HQVGA (240x160) */
        FRAME_FORMAT_QVGA = 4,/*!< QVGA (320x240) */
        FRAME_FORMAT_CIF = 5,/*!< CIF (352x288) */
        FRAME_FORMAT_HVGA = 6,/*!< HVGA (480x320) */
        FRAME_FORMAT_VGA = 7,/*!< VGA (640x480) */
        FRAME_FORMAT_WXGA_H = 8,/*!< WXGA_H (1280x720) */
        FRAME_FORMAT_DS311 = 9,/*!< DS311 (320x120) */
        FRAME_FORMAT_XGA = 10,/*!< XGA (1024x768) */
        FRAME_FORMAT_SVGA = 11,/*!< SVGA (800x600) */
        FRAME_FORMAT_OVVGA = 12,/*!< OVVGA (636x480) */
        FRAME_FORMAT_WHVGA = 13,/*!< WHVGA (640x240) */
        FRAME_FORMAT_NHD = 14,/*!< nHD (640x360) */
        FRAME_FORMAT_STEREOLR = 15,/*!< StereoLR (320x480) */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String FrameFormat_toString_p (FrameFormat value);
    #endif
    /// Converts a DepthSense::FrameFormat value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::FrameFormat, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string FrameFormat_toString (FrameFormat value)
    {
        return FrameFormat_toString_p(value).unmarshal();
    }
    /// The image compression type
    ///
    /// A type enumerating the various compression types supported by
    /// DepthSense SDK.
    enum CompressionType
    {
        COMPRESSION_TYPE_YUY2 = 0,/*!< Y'UV422 */
        COMPRESSION_TYPE_MJPEG = 1,/*!< MJPEG */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CompressionType_toString_p (CompressionType value);
    #endif
    /// Converts a DepthSense::CompressionType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CompressionType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CompressionType_toString (CompressionType value)
    {
        return CompressionType_toString_p(value).unmarshal();
    }
    /// The auto exposure mode
    ///
    /// The supported auto exposure modes.
    enum ExposureAuto
    {
        EXPOSURE_AUTO_MANUAL = 0,/*!< Manual exposure mode */
        EXPOSURE_AUTO_APERTURE_PRIORITY = 1,/*!< Aperture priority exposure mode */
        EXPOSURE_AUTO_AUTO = 2,/*!< Auto exposure mode */
        EXPOSURE_AUTO_SHUTTER_PRIORITY = 3,/*!< Shutter priority exposure mode */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String ExposureAuto_toString_p (ExposureAuto value);
    #endif
    /// Converts a DepthSense::ExposureAuto value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::ExposureAuto, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string ExposureAuto_toString (ExposureAuto value)
    {
        return ExposureAuto_toString_p(value).unmarshal();
    }
    /// The power line frequency
    ///
    /// The supported power line frequencies.
    enum PowerLineFrequency
    {
        POWER_LINE_FREQUENCY_DISABLED = 0,/*!< disabled */
        POWER_LINE_FREQUENCY_50HZ = 1,/*!< 50 Hz */
        POWER_LINE_FREQUENCY_60HZ = 2,/*!< 60 Hz */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String PowerLineFrequency_toString_p (PowerLineFrequency value);
    #endif
    /// Converts a DepthSense::PowerLineFrequency value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::PowerLineFrequency, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string PowerLineFrequency_toString (PowerLineFrequency value)
    {
        return PowerLineFrequency_toString_p(value).unmarshal();
    }
    /// The camera plane to project on
    ///
    /// The camera plane to project the 3D points on.
    enum CameraPlane
    {
        CAMERA_PLANE_COLOR = 0,/*!< the color plane */
        CAMERA_PLANE_DEPTH = 1,/*!< the depth plane */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CameraPlane_toString_p (CameraPlane value);
    #endif
    /// Converts a DepthSense::CameraPlane value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CameraPlane, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CameraPlane_toString (CameraPlane value)
    {
        return CameraPlane_toString_p(value).unmarshal();
    }
    /// The type of coordinate system
    ///
    /// The type of coordinate system
    enum CoordinateSystemType
    {
        COORDINATE_SYSTEM_TYPE_LEFT_HANDED = 0,/*!< A left handed coordinate system  */
        COORDINATE_SYSTEM_TYPE_RIGHT_HANDED = 1,/*!< A right handed coordinate system */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CoordinateSystemType_toString_p (CoordinateSystemType value);
    #endif
    /// Converts a DepthSense::CoordinateSystemType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CoordinateSystemType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CoordinateSystemType_toString (CoordinateSystemType value)
    {
        return CoordinateSystemType_toString_p(value).unmarshal();
    }
    /// The laser
    enum Laser
    {
        LASER_NONE = 0,
        LASER_ZERO = 1,
        LASER_ONE = 2,
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String Laser_toString_p (Laser value);
    #endif
    /// Converts a DepthSense::Laser value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Laser, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string Laser_toString (Laser value)
    {
        return Laser_toString_p(value).unmarshal();
    }
    namespace Depth
    {
        /// The type of IMU data 
        ///   
        /// A type enumerating the various types of IMU data.
        enum ImuDataType
        {
            IMU_DATA_TYPE_UNKNOWN = -1,/*!< unknown */
            IMU_DATA_TYPE_ACCELEROMETER = 65,/*!< Accelerometer */
            IMU_DATA_TYPE_COMPASS = 67,/*!< Compass */
            IMU_DATA_TYPE_GYROSCOPE = 71,/*!< Gyroscope */
            IMU_DATA_TYPE_CALIBRATION = 75,/*!< Calibration */
            IMU_DATA_TYPE_QUATERNION = 81,/*!< Quaternion */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String ImuDataType_toString_p (ImuDataType value);
        #endif
        /// Converts a DepthSense::Depth::ImuDataType value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::ImuDataType, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string ImuDataType_toString (ImuDataType value)
        {
            return ImuDataType_toString_p(value).unmarshal();
        }
        /// The mode of the camera
        ///
        /// A type enumerating the various operating modes supported
        /// by depth sensors.
        enum CameraMode
        {
            CAMERA_MODE_UNKNOWN = -1,
            CAMERA_MODE_CLOSE_MODE = 0,
            CAMERA_MODE_LONG_RANGE = 1,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String CameraMode_toString_p (CameraMode value);
        #endif
        /// Converts a DepthSense::Depth::CameraMode value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::CameraMode, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string CameraMode_toString (CameraMode value)
        {
            return CameraMode_toString_p(value).unmarshal();
        }
        /// Button ID
        enum ButtonID
        {
            BUTTON_IDBUTTON_0 = 0,
            BUTTON_IDBUTTON_1 = 1,
            BUTTON_IDBUTTON_2 = 2,
            BUTTON_IDBUTTON_3 = 3,
            BUTTON_IDBUTTON_4 = 4,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DSI::String ButtonID_toString_p (ButtonID value);
        #endif
        /// Converts a DepthSense::Depth::ButtonID value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Depth::ButtonID, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string ButtonID_toString (ButtonID value)
        {
            return ButtonID_toString_p(value).unmarshal();
        }
    };
};
namespace DepthSense
{
    /// \struct Vertex DepthSense.hxx
    /// A point in space as defined by its integer coordinates
    ///   
    /// The Vertex struct holds the position of a point in space as
    /// defined by its 3D integer coordinates.
    struct DEPTHSENSE_API Vertex
    {
        Vertex ();
        /// Constructs a Vertex instance
        ///
        /// Constructs a Vertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Vertex::x field
        /// \param y the value of the Vertex::y field
        /// \param z the value of the Vertex::z field
        Vertex (int16_t x, int16_t y, int16_t z);
        /// the x value
        int16_t x;
        /// the y value
        int16_t y;
        /// the z value
        int16_t z;
        /// Compares two Vertex instances for equality
        ///
        /// Checks whether the current Vertex instance is equal to the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Vertex& other) const;
        /// Compares two Vertex instances for inequality
        ///
        /// Checks whether the current Vertex instance is different from the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Vertex& other) const;
    };
    /// \struct FPVertex DepthSense.hxx
    /// A point in space as defined by its floating point coordinates
    ///   
    /// The FPVertex struct holds the position of a point in space as
    /// defined by its 3D floating point coordinates.
    struct DEPTHSENSE_API FPVertex
    {
        FPVertex ();
        /// Constructs a FPVertex instance
        ///
        /// Constructs a FPVertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the FPVertex::x field
        /// \param y the value of the FPVertex::y field
        /// \param z the value of the FPVertex::z field
        FPVertex (float x, float y, float z);
        /// the x value
        float x;
        /// the y value
        float y;
        /// the z value
        float z;
        /// Compares two FPVertex instances for equality
        ///
        /// Checks whether the current FPVertex instance is equal to the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPVertex& other) const;
        /// Compares two FPVertex instances for inequality
        ///
        /// Checks whether the current FPVertex instance is different from the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPVertex& other) const;
    };
    /// \struct UV DepthSense.hxx
    /// UV coordinates
    ///   
    /// The UV struct holds the UV coordinates of a point of a UV map.
    struct DEPTHSENSE_API UV
    {
        UV ();
        /// Constructs a UV instance
        ///
        /// Constructs a UV instance, initializing the instance fields with the provided values.
        ///
        /// \param u the value of the UV::u field
        /// \param v the value of the UV::v field
        UV (float u, float v);
        /// the u value
        float u;
        /// the v value
        float v;
        /// Compares two UV instances for equality
        ///
        /// Checks whether the current UV instance is equal to the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const UV& other) const;
        /// Compares two UV instances for inequality
        ///
        /// Checks whether the current UV instance is different from the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const UV& other) const;
    };
    /// \struct IntrinsicParameters DepthSense.hxx
    /// The intrinsic parameters of the camera system
    ///   
    /// The IntrinsicParameters struct holds the intrinsic parameters
    /// of the camera system.
    struct DEPTHSENSE_API IntrinsicParameters
    {
        IntrinsicParameters ();
        /// Constructs a IntrinsicParameters instance
        ///
        /// Constructs a IntrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param width the value of the IntrinsicParameters::width field
        /// \param height the value of the IntrinsicParameters::height field
        /// \param fx the value of the IntrinsicParameters::fx field
        /// \param fy the value of the IntrinsicParameters::fy field
        /// \param cx the value of the IntrinsicParameters::cx field
        /// \param cy the value of the IntrinsicParameters::cy field
        /// \param k1 the value of the IntrinsicParameters::k1 field
        /// \param k2 the value of the IntrinsicParameters::k2 field
        /// \param k3 the value of the IntrinsicParameters::k3 field
        /// \param p1 the value of the IntrinsicParameters::p1 field
        /// \param p2 the value of the IntrinsicParameters::p2 field
        IntrinsicParameters (int32_t width, int32_t height, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2);
        /// the width of the map when the frame was captured
        int32_t width;
        /// the height of the map when the frame was captured
        int32_t height;
        /// the focal length along the x axis, expressed in pixel units
        float fx;
        /// the focal length along the y axis, expressed in pixel units
        float fy;
        /// the central point along the x axis, expressed in pixel units
        float cx;
        /// the central point along the y axis, expressed in pixel units
        float cy;
        /// the first radial distortion coefficient
        float k1;
        /// the second radial distortion coefficient
        float k2;
        /// the third radial distortion coefficient
        float k3;
        /// the first tangential distortion coefficient
        float p1;
        /// the second tangential distortion coefficient
        float p2;
        /// Compares two IntrinsicParameters instances for equality
        ///
        /// Checks whether the current IntrinsicParameters instance is equal to the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const IntrinsicParameters& other) const;
        /// Compares two IntrinsicParameters instances for inequality
        ///
        /// Checks whether the current IntrinsicParameters instance is different from the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const IntrinsicParameters& other) const;
    };
    /// \struct ExtrinsicParameters DepthSense.hxx
    /// The extrinsic parameters of the camera system
    ///   
    /// The ExtrinsicsParameters struct holds the extrinsic parameters
    /// of the camera system. Elements are given row by row.
    struct DEPTHSENSE_API ExtrinsicParameters
    {
        ExtrinsicParameters ();
        /// Constructs a ExtrinsicParameters instance
        ///
        /// Constructs a ExtrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param r11 the value of the ExtrinsicParameters::r11 field
        /// \param r12 the value of the ExtrinsicParameters::r12 field
        /// \param r13 the value of the ExtrinsicParameters::r13 field
        /// \param r21 the value of the ExtrinsicParameters::r21 field
        /// \param r22 the value of the ExtrinsicParameters::r22 field
        /// \param r23 the value of the ExtrinsicParameters::r23 field
        /// \param r31 the value of the ExtrinsicParameters::r31 field
        /// \param r32 the value of the ExtrinsicParameters::r32 field
        /// \param r33 the value of the ExtrinsicParameters::r33 field
        /// \param t1 the value of the ExtrinsicParameters::t1 field
        /// \param t2 the value of the ExtrinsicParameters::t2 field
        /// \param t3 the value of the ExtrinsicParameters::t3 field
        ExtrinsicParameters (float r11, float r12, float r13, float r21, float r22, float r23, float r31, float r32, float r33, float t1, float t2, float t3);
        /// the r11 parameter
        float r11;
        /// the r12 parameter
        float r12;
        /// the r13 parameter
        float r13;
        /// the r21 parameter
        float r21;
        /// the r22 parameter
        float r22;
        /// the r32 parameter
        float r23;
        /// the r31 parameter
        float r31;
        /// the r32 parameter
        float r32;
        /// the r33 parameter
        float r33;
        /// the t1 parameter
        float t1;
        /// the t2 parameter
        float t2;
        /// the t3 parameter
        float t3;
        /// Compares two ExtrinsicParameters instances for equality
        ///
        /// Checks whether the current ExtrinsicParameters instance is equal to the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const ExtrinsicParameters& other) const;
        /// Compares two ExtrinsicParameters instances for inequality
        ///
        /// Checks whether the current ExtrinsicParameters instance is different from the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const ExtrinsicParameters& other) const;
    };
    /// \struct StereoCameraParameters DepthSense.hxx
    /// The intrinsic and extrinsic parameters of the camera system
    ///   
    /// The StereoCameraParameters holds the intrinsic and extrinsic
    /// parameters of the camera system.
    struct DEPTHSENSE_API StereoCameraParameters
    {
        StereoCameraParameters ();
        /// Constructs a StereoCameraParameters instance
        ///
        /// Constructs a StereoCameraParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param depthIntrinsics the value of the StereoCameraParameters::depthIntrinsics field
        /// \param colorIntrinsics the value of the StereoCameraParameters::colorIntrinsics field
        /// \param extrinsics the value of the StereoCameraParameters::extrinsics field
        StereoCameraParameters (DepthSense::IntrinsicParameters depthIntrinsics, DepthSense::IntrinsicParameters colorIntrinsics, DepthSense::ExtrinsicParameters extrinsics);
        /// The intrinsic parameters of the depth camera
        DepthSense::IntrinsicParameters depthIntrinsics;
        /// The intrinsic parameters of the color camera
        DepthSense::IntrinsicParameters colorIntrinsics;
        /// The extrinsic parameters of the system. The coordinate system used 
        /// is the one specified through \c DepthNode::coordinateSystemType property.
        DepthSense::ExtrinsicParameters extrinsics;
        /// Compares two StereoCameraParameters instances for equality
        ///
        /// Checks whether the current StereoCameraParameters instance is equal to the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const StereoCameraParameters& other) const;
        /// Compares two StereoCameraParameters instances for inequality
        ///
        /// Checks whether the current StereoCameraParameters instance is different from the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const StereoCameraParameters& other) const;
    };
    /// \struct Point2D DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates
    ///
    /// The Point2D struct holds the position of a point in the
    /// cartesian space as defined by its floating point pixel
    /// coordinates. The origin of the coordinate system is the
    /// topleft corner of the image.
    struct DEPTHSENSE_API Point2D
    {
        Point2D ();
        /// Constructs a Point2D instance
        ///
        /// Constructs a Point2D instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Point2D::x field
        /// \param y the value of the Point2D::y field
        Point2D (float x, float y);
        /// the x coordinate
        float x;
        /// the y coordinate
        float y;
        /// Compares two Point2D instances for equality
        ///
        /// Checks whether the current Point2D instance is equal to the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Point2D& other) const;
        /// Compares two Point2D instances for inequality
        ///
        /// Checks whether the current Point2D instance is different from the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Point2D& other) const;
    };
    /// \struct Extended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its integral cartesian depth
    ///
    /// The Extended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its integral cartesian depth.
    struct DEPTHSENSE_API Extended2DPoint
    {
        Extended2DPoint ();
        /// Constructs a Extended2DPoint instance
        ///
        /// Constructs a Extended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the Extended2DPoint::point field
        /// \param depth the value of the Extended2DPoint::depth field
        Extended2DPoint (DepthSense::Point2D point, int16_t depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location, expressed in millimeters
        int16_t depth;
        /// Compares two Extended2DPoint instances for equality
        ///
        /// Checks whether the current Extended2DPoint instance is equal to the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Extended2DPoint& other) const;
        /// Compares two Extended2DPoint instances for inequality
        ///
        /// Checks whether the current Extended2DPoint instance is different from the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Extended2DPoint& other) const;
    };
    /// \struct FPExtended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its floating point cartesian
    /// depth
    ///
    /// The FPExtended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its floating point cartesian depth.
    struct DEPTHSENSE_API FPExtended2DPoint
    {
        FPExtended2DPoint ();
        /// Constructs a FPExtended2DPoint instance
        ///
        /// Constructs a FPExtended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the FPExtended2DPoint::point field
        /// \param depth the value of the FPExtended2DPoint::depth field
        FPExtended2DPoint (DepthSense::Point2D point, float depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location.
        float depth;
        /// Compares two FPExtended2DPoint instances for equality
        ///
        /// Checks whether the current FPExtended2DPoint instance is equal to the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPExtended2DPoint& other) const;
        /// Compares two FPExtended2DPoint instances for inequality
        ///
        /// Checks whether the current FPExtended2DPoint instance is different from the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPExtended2DPoint& other) const;
    };
    /// \struct Version DepthSense.hxx
    /// DepthSense version information
    ///
    /// The Version struct contains version information for the DepthSenseSDK software.
    struct DEPTHSENSE_API Version
    {
        Version ();
        /// Constructs a Version instance
        ///
        /// Constructs a Version instance, initializing the instance fields with the provided values.
        ///
        /// \param major the value of the Version::major field
        /// \param minor the value of the Version::minor field
        /// \param patch the value of the Version::patch field
        /// \param build the value of the Version::build field
        Version (int32_t major, int32_t minor, int32_t patch, int32_t build);
        /// the major version number
        int32_t major;
        /// the minor version number
        int32_t minor;
        /// the patch level
        int32_t patch;
        /// the package build number
        int32_t build;
        /// Compares two Version instances for equality
        ///
        /// Checks whether the current Version instance is equal to the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Version& other) const;
        /// Compares two Version instances for inequality
        ///
        /// Checks whether the current Version instance is different from the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Version& other) const;
    };
    namespace Audio
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of an audio node
        ///   
        /// The Configuration struct holds the configuration of an audio node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param channels the value of the Configuration::channels field
            /// \param bitsPerSample the value of the Configuration::bitsPerSample field
            /// \param sampleRate the value of the Configuration::sampleRate field
            Configuration (int32_t channels, int32_t bitsPerSample, int32_t sampleRate);
            /// the number of audio channels
            int32_t channels;
            /// the number of bits per sample
            int32_t bitsPerSample;
            /// the sample rate in Hz
            int32_t sampleRate;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
    };
    namespace Color
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a color node
        ///   
        /// The Configuration struct holds the configuration of a color node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param powerLineFrequency the value of the Configuration::powerLineFrequency field
            /// \param compression the value of the Configuration::compression field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::PowerLineFrequency powerLineFrequency, DepthSense::CompressionType compression);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the power line frequency in Hz
            DepthSense::PowerLineFrequency powerLineFrequency;
            /// the compression type
            DepthSense::CompressionType compression;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
    };
    namespace Depth
    {
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a depth node
        ///   
        /// The Configuration struct holds the configuration of a depth node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param mode the value of the Configuration::mode field
            /// \param saturation the value of the Configuration::saturation field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::Depth::CameraMode mode, bool saturation);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the mode
            DepthSense::Depth::CameraMode mode;
            /// whether the saturation is enabled or not
            bool saturation;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// \struct Acceleration DepthSense.hxx
        /// The acceleration returned by the camera
        ///
        /// The Acceleration struct holds the 3 axis acceleration
        /// expressed in g (9.81 m/s²) units. Coordinates are
        /// expressed in the same coordinates as the vertices.
        struct DEPTHSENSE_API Acceleration
        {
            Acceleration ();
            /// Constructs a Acceleration instance
            ///
            /// Constructs a Acceleration instance, initializing the instance fields with the provided values.
            ///
            /// \param x the value of the Acceleration::x field
            /// \param y the value of the Acceleration::y field
            /// \param z the value of the Acceleration::z field
            Acceleration (float x, float y, float z);
            /// the x acceleration
            float x;
            /// the y acceleration
            float y;
            /// the z acceleration
            float z;
            /// Compares two Acceleration instances for equality
            ///
            /// Checks whether the current Acceleration instance is equal to the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Acceleration& other) const;
            /// Compares two Acceleration instances for inequality
            ///
            /// Checks whether the current Acceleration instance is different from the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Acceleration& other) const;
        };
    };
};
namespace DepthSense
{
    /// \class Exception DepthSense.hxx
    /// The base exception class
    ///   
    /// The Exception class is the common base class for all
    /// DepthSense exception types. It is never thrown directly, one
    /// of its subclasses is.
    ///
    /// DepthSense exceptions feature automatic memory management,
    /// implemented with reference counted smart pointer mechanisms.
    ///
    /// The Exception class derives from \c std::exception.
    class DEPTHSENSE_API Exception : public std::exception
    {
        #ifndef DEPTHSENSE_DOC
        protected:
        void* _data;
        #endif
        public:
        #ifndef DEPTHSENSE_DOC
        Exception (const Exception& other);
        Exception& operator= (const Exception& other);
        virtual ~Exception () throw ();
        virtual const char* what () const throw ();
        #endif
        protected:
        Exception ();
        Exception (void* data);
        private:
        Exception (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setMessage (std::string value);
        #endif
        public:
        /// Returns the error message
        ///   
        /// Returns the error message contained in the current
        /// exception object.
        ///
        /// \return the error message
        std::string getMessage () const;
        private:
        friend class PException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ArgumentException DepthSense.hxx
    /// The type of the exception thrown when an argument is unset or invalid
    ///   
    /// ArgumentException is thrown when a method argument or property
    /// value is unset when it should be set or is outside of the
    /// range of allowed values.
    class DEPTHSENSE_API ArgumentException : public DepthSense::Exception
    {
        protected:
        ArgumentException ();
        ArgumentException (void* data);
        private:
        ArgumentException (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setParameterName (std::string value);
        #endif
        public:
        /// Returns the name of the corresponding parameter
        ///   
        /// Returns the name of the method parameter whose argument is
        /// invalid. For a property value, this name is always \c
        /// value.
        ///
        /// \return the parameter name
        std::string getParameterName () const;
        private:
        friend class PArgumentException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TransportException DepthSense.hxx
    /// The type of the exception thrown when a network or protocol
    /// error has occurred
    ///
    /// TransportException is thrown when a network I/O operation has
    /// failed, or when an invalid protocol packet has been received.
    class DEPTHSENSE_API TransportException : public DepthSense::Exception
    {
        protected:
        TransportException ();
        TransportException (void* data);
        private:
        TransportException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTransportException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InitializationException DepthSense.hxx
    /// The type of the exception thrown when an initialization error
    /// has occurred
    ///
    /// InitializationException is thrown when a component has failed
    /// to initialize properly.
    class DEPTHSENSE_API InitializationException : public DepthSense::Exception
    {
        protected:
        InitializationException ();
        InitializationException (void* data);
        private:
        InitializationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInitializationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TimeoutException DepthSense.hxx
    /// The type of the exception thrown when a timeout condition occurs
    ///
    /// TimeoutException is thrown when the user-provided timeout of a
    /// method accepting a timeout parameter expires.
    class DEPTHSENSE_API TimeoutException : public DepthSense::Exception
    {
        protected:
        TimeoutException ();
        TimeoutException (void* data);
        private:
        TimeoutException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTimeoutException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ConfigurationException DepthSense.hxx
    /// The type of the exception thrown when a valid configuration
    /// failed to apply
    ///   
    /// ConfigurationException is thrown when a valid configuration
    /// could not be applied because of a device or software error.
    ///
    /// Contrast with ArgumentException, which is thrown by
    /// AudioNode::setConfiguration(), ColorNode::setConfiguration()
    /// and DepthNode::setConfiguration() when the user-provided
    /// configuration is invalid.
    class DEPTHSENSE_API ConfigurationException : public DepthSense::Exception
    {
        protected:
        ConfigurationException ();
        ConfigurationException (void* data);
        private:
        ConfigurationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PConfigurationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class StreamingException DepthSense.hxx
    /// The type of the exception thrown when a streaming error has
    /// occurred
    ///
    /// StreamingException is thrown when a device or software error
    /// prevents streaming from starting or from resuming after a
    /// configuration change.
    class DEPTHSENSE_API StreamingException : public DepthSense::Exception
    {
        protected:
        StreamingException ();
        StreamingException (void* data);
        private:
        StreamingException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PStreamingException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class UnauthorizedAccessException DepthSense.hxx
    /// The type of the exception thrown when access to a privileged
    /// operation is denied
    ///    
    /// UnauthorizedAccessException is thrown when a privileged method
    /// is called or when a privileged property is set.
    ///
    /// A privileged method or property is one which requires
    /// exclusive control of a device or node. Such exclusive control
    /// can be obtained with a call to Context::requestControl().
    class DEPTHSENSE_API UnauthorizedAccessException : public DepthSense::Exception
    {
        protected:
        UnauthorizedAccessException ();
        UnauthorizedAccessException (void* data);
        private:
        UnauthorizedAccessException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PUnauthorizedAccessException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InvalidOperationException DepthSense.hxx
    /// The type of the exception thrown when the current state of an
    /// object does not support the requested operation
    ///   
    /// InvalidOperationException is thrown when an operation is not valid
    /// because of the current state of an object.
    ///
    /// Contrast with NotSupportedException, which is thrown when an
    /// operation is not implemented, regardless of any program or
    /// library state.
    class DEPTHSENSE_API InvalidOperationException : public DepthSense::Exception
    {
        protected:
        InvalidOperationException ();
        InvalidOperationException (void* data);
        private:
        InvalidOperationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInvalidOperationException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class NotSupportedException DepthSense.hxx
    /// The type of the exception thrown when a unsupported operation
    /// is requested
    ///
    /// NotSupportedException is thrown when an unimplemented method
    /// or property is used.
    class DEPTHSENSE_API NotSupportedException : public DepthSense::Exception
    {
        protected:
        NotSupportedException ();
        NotSupportedException (void* data);
        private:
        NotSupportedException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PNotSupportedException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class IOException DepthSense.hxx
    /// The type of the exception throw when a device or file I/O
    /// operation has failed
    ///   
    /// IOException is thrown when an operation on a device or a file
    /// has failed because of an I/O error.
    class DEPTHSENSE_API IOException : public DepthSense::Exception
    {
        protected:
        IOException ();
        IOException (void* data);
        private:
        IOException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PIOException;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    namespace Audio
    {
    };
    namespace Color
    {
    };
    namespace Depth
    {
    };
};
namespace DepthSense
{
    /// \class Interface DepthSense.hxx
    /// The base interface class
    ///
    /// The Interface class is the common base class for all
    /// DepthSense interfaces. It provides facilities for
    /// introspecting the runtime type of an object and for setting or
    /// unsetting the current instance.
    ///
    /// The Interface class and its subclasses feature automatic
    /// memory management, implemented with reference counted smart
    /// pointer mechanisms.
    class Interface
    {
        private:
        void* _instance;
        DEPTHSENSE_API Interface (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const Interface& other);
        DEPTHSENSE_API Interface& operator= (const Interface& other);
        #endif
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        DEPTHSENSE_API ~Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const DepthSense::Audio::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Color::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::IMUData& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::SampleData& iface);
        DEPTHSENSE_API Interface (const DepthSense::Depth::ButtonEventData& iface);
        DEPTHSENSE_API Interface (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::UnsupportedNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Context& iface);
        DEPTHSENSE_API Interface (const DepthSense::Device& iface);
        DEPTHSENSE_API Interface (const DepthSense::Node& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Interface& other) const;
        #endif
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        /// Returns the DepthSense::Interface type object
        ///
        /// Returns the DepthSense::Interface type object
        ///
        /// \return the DepthSense::Interface type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct PropertyChangedData DepthSense.hxx
        /// Holds the DepthSense::Interface::PropertyChangedEvent arguments
        ///
        /// The PropertyChangedData struct holds the DepthSense::Interface::PropertyChangedEvent parameters and is passed to callbacks connected to that event.
        struct PropertyChangedData
        {
            /// the property whose value has changed
            DepthSense::PropertyBase property;
        };
        /// \class PropertyChangedEvent DepthSense.hxx
        /// Event raised when a property has changed
        ///
        /// The \c propertyChanged event is raised when the value of a
        /// property has changed.
        ///
        /// \param property the property whose value has changed
        class PropertyChangedEvent : public DepthSense::Event<DepthSense::Interface, PropertyChangedData>
        {
            private:
            PropertyChangedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Interface, PropertyChangedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(func)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_method))(obj, data.property);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
    };
    /// \class Node DepthSense.hxx
    /// Represents a stream data source
    ///   
    /// The Node class represents a stream data source belonging to a given
    /// device. A device may contain several nodes (depth and color sensors,
    /// and a microphone array).
    class Node
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Node (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        public:
        DEPTHSENSE_API Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Node (const Node& other);
        DEPTHSENSE_API Node& operator= (const Node& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Node (const DepthSense::Interface& iface);
        DEPTHSENSE_API Node (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Node (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Node (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Node (const DepthSense::UnsupportedNode& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Node& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Node type object
        ///
        /// Returns the DepthSense::Node type object
        ///
        /// \return the DepthSense::Node type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Audio
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Audio::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Audio::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Audio::SampleData type object
            ///
            /// Returns the DepthSense::Audio::SampleData type object
            ///
            /// \return the DepthSense::Audio::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The audio data.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > audioData;
            #endif
            /// Gets the value of the SampleData::audioData property
            ///
            /// Gets the value of the SampleData::audioData property.
            ///
            ///
            /// \return the value of the SampleData::audioData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getAudioData ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Audio::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Audio::Configuration getCaptureConfiguration ();
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// The time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    /// \class AudioNode DepthSense.hxx
    /// Represents an audio stream data source
    ///   
    /// The AudioNode class allows to capture audio data with the microphone
    /// array of a given camera device.
    class AudioNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API AudioNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API AudioNode (const AudioNode& other);
        DEPTHSENSE_API AudioNode& operator= (const AudioNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::AudioNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::AudioNode type object
        ///
        /// Returns the DepthSense::AudioNode type object
        ///
        /// \return the DepthSense::AudioNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of an audio node
        ///   
        /// The Configuration struct holds the configuration of an audio node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param channels the value of the Configuration::channels field
            /// \param bitsPerSample the value of the Configuration::bitsPerSample field
            /// \param sampleRate the value of the Configuration::sampleRate field
            Configuration (int32_t channels, int32_t bitsPerSample, int32_t sampleRate);
            /// the number of audio channels
            int32_t channels;
            /// the number of bits per sample
            int32_t bitsPerSample;
            /// the sample rate in Hz
            int32_t sampleRate;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// The node configuration
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::AudioNode::Configuration configuration;
        #endif
        /// Gets the value of the AudioNode::configuration property
        ///
        /// Gets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::Configuration getConfiguration ();
        /// Sets the value of the AudioNode::configuration property
        ///
        /// Sets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::AudioNode::Configuration value);
        /// Checks whether property AudioNode::configuration is read-only
        ///
        /// Checks whether property AudioNode::configuration is read-only.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The AudioNode::configurations property specifies the list of
        /// supported node configurations.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::AudioNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::AudioNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the AudioNode::configurations property
        ///
        /// Gets the value of the AudioNode::configurations property.
        ///
        ///
        /// \return the value of the AudioNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::AudioNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::AudioNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The recording level
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property float inputMixerLevel;
        #endif
        /// Gets the value of the AudioNode::inputMixerLevel property
        ///
        /// Gets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::inputMixerLevel property
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getInputMixerLevel ();
        /// Sets the value of the AudioNode::inputMixerLevel property
        ///
        /// Sets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getInputMixerLevel(), inputMixerLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setInputMixerLevel (float value);
        /// Checks whether property AudioNode::inputMixerLevel is read-only
        ///
        /// Checks whether property AudioNode::inputMixerLevel is read-only.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::inputMixerLevel is read-only
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool inputMixerLevelIsReadOnly ();
        /// Whether to mute the recording
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool mute;
        #endif
        /// Gets the value of the AudioNode::mute property
        ///
        /// Gets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::mute property
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getMute ();
        /// Sets the value of the AudioNode::mute property
        ///
        /// Sets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getMute(), muteIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setMute (bool value);
        /// Checks whether property AudioNode::mute is read-only
        ///
        /// Checks whether property AudioNode::mute is read-only.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::mute is read-only
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool muteIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::AudioNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::AudioNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the audio data
            ::DepthSense::Pointer< uint8_t > audioData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::AudioNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when an audio sample is captured
        ///
        /// The \c newSampleReceived event is raised when an audio sample
        /// is captured.
        ///
        /// \param audioData the audio data
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::AudioNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::AudioNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Audio::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when an audio sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when an audio sample
        /// is captured.                         
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data, void (*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::Audio::SampleData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Color
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::ColorNode;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Color::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Color::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Color::SampleData type object
            ///
            /// Returns the DepthSense::Color::SampleData type object
            ///
            /// \return the DepthSense::Color::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > colorMap;
            #endif
            /// Gets the value of the SampleData::colorMap property
            ///
            /// Gets the value of the SampleData::colorMap property.
            ///
            ///
            /// \return the value of the SampleData::colorMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getColorMap ();
            /// The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< uint8_t > compressedData;
            #endif
            /// Gets the value of the SampleData::compressedData property
            ///
            /// Gets the value of the SampleData::compressedData property.
            ///
            ///
            /// \return the value of the SampleData::compressedData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< uint8_t > getCompressedData ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Color::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Color::Configuration getCaptureConfiguration ();
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// The time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    /// \class ColorNode DepthSense.hxx
    /// Represents a color stream data source
    ///
    /// The ColorNode class allows to capture pixel data with the RGB sensor
    /// of a given camera device.
    class ColorNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API ColorNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API ColorNode (const ColorNode& other);
        DEPTHSENSE_API ColorNode& operator= (const ColorNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::ColorNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::ColorNode type object
        ///
        /// Returns the DepthSense::ColorNode type object
        ///
        /// \return the DepthSense::ColorNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a color node
        ///   
        /// The Configuration struct holds the configuration of a color node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param powerLineFrequency the value of the Configuration::powerLineFrequency field
            /// \param compression the value of the Configuration::compression field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::PowerLineFrequency powerLineFrequency, DepthSense::CompressionType compression);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the power line frequency in Hz
            DepthSense::PowerLineFrequency powerLineFrequency;
            /// the compression type
            DepthSense::CompressionType compression;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// Whether to enable the color map
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableColorMap;
        #endif
        /// Gets the value of the ColorNode::enableColorMap property
        ///
        /// Gets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableColorMap property
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableColorMap ();
        /// Sets the value of the ColorNode::enableColorMap property
        ///
        /// Sets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableColorMap(), enableColorMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableColorMap (bool value);
        /// Checks whether property ColorNode::enableColorMap is read-only
        ///
        /// Checks whether property ColorNode::enableColorMap is read-only.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableColorMap is read-only
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableColorMapIsReadOnly ();
        /// Whether to enable the compressed data
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableCompressedData;
        #endif
        /// Gets the value of the ColorNode::enableCompressedData property
        ///
        /// Gets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableCompressedData property
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableCompressedData ();
        /// Sets the value of the ColorNode::enableCompressedData property
        ///
        /// Sets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableCompressedData(), enableCompressedDataIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableCompressedData (bool value);
        /// Checks whether property ColorNode::enableCompressedData is read-only
        ///
        /// Checks whether property ColorNode::enableCompressedData is read-only.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableCompressedData is read-only
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableCompressedDataIsReadOnly ();
        /// The node configuration
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ColorNode::Configuration configuration;
        #endif
        /// Gets the value of the ColorNode::configuration property
        ///
        /// Gets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return the value of the ColorNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::Configuration getConfiguration ();
        /// Sets the value of the ColorNode::configuration property
        ///
        /// Sets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::ColorNode::Configuration value);
        /// Checks whether property ColorNode::configuration is read-only
        ///
        /// Checks whether property ColorNode::configuration is read-only.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return whether property ColorNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The ColorNode::configurations property specifies the list of
        /// supported node configurations.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::ColorNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::ColorNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the ColorNode::configurations property
        ///
        /// Gets the value of the ColorNode::configurations property.
        ///
        ///
        /// \return the value of the ColorNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::ColorNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::ColorNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The brightness
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t brightness;
        #endif
        /// Gets the value of the ColorNode::brightness property
        ///
        /// Gets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::brightness property
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getBrightness ();
        /// Sets the value of the ColorNode::brightness property
        ///
        /// Sets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getBrightness(), brightnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setBrightness (int32_t value);
        /// Checks whether property ColorNode::brightness is read-only
        ///
        /// Checks whether property ColorNode::brightness is read-only.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::brightness is read-only
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool brightnessIsReadOnly ();
        /// The contrast
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t contrast;
        #endif
        /// Gets the value of the ColorNode::contrast property
        ///
        /// Gets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::contrast property
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getContrast ();
        /// Sets the value of the ColorNode::contrast property
        ///
        /// Sets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getContrast(), contrastIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setContrast (int32_t value);
        /// Checks whether property ColorNode::contrast is read-only
        ///
        /// Checks whether property ColorNode::contrast is read-only.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::contrast is read-only
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool contrastIsReadOnly ();
        /// The saturation
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t saturation;
        #endif
        /// Gets the value of the ColorNode::saturation property
        ///
        /// Gets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::saturation property
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSaturation ();
        /// Sets the value of the ColorNode::saturation property
        ///
        /// Sets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSaturation(), saturationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSaturation (int32_t value);
        /// Checks whether property ColorNode::saturation is read-only
        ///
        /// Checks whether property ColorNode::saturation is read-only.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::saturation is read-only
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool saturationIsReadOnly ();
        /// The hue
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t hue;
        #endif
        /// Gets the value of the ColorNode::hue property
        ///
        /// Gets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::hue property
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHue ();
        /// Sets the value of the ColorNode::hue property
        ///
        /// Sets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHue(), hueIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHue (int32_t value);
        /// Checks whether property ColorNode::hue is read-only
        ///
        /// Checks whether property ColorNode::hue is read-only.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::hue is read-only
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool hueIsReadOnly ();
        /// The gamma
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t gamma;
        #endif
        /// Gets the value of the ColorNode::gamma property
        ///
        /// Gets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::gamma property
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getGamma ();
        /// Sets the value of the ColorNode::gamma property
        ///
        /// Sets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getGamma(), gammaIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGamma (int32_t value);
        /// Checks whether property ColorNode::gamma is read-only
        ///
        /// Checks whether property ColorNode::gamma is read-only.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::gamma is read-only
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gammaIsReadOnly ();
        /// The white balance
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t whiteBalance;
        #endif
        /// Gets the value of the ColorNode::whiteBalance property
        ///
        /// Gets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalance property
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getWhiteBalance ();
        /// Sets the value of the ColorNode::whiteBalance property
        ///
        /// Sets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalance(), whiteBalanceIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalance (int32_t value);
        /// Checks whether property ColorNode::whiteBalance is read-only
        ///
        /// Checks whether property ColorNode::whiteBalance is read-only.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalance is read-only
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceIsReadOnly ();
        /// The sharpness
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t sharpness;
        #endif
        /// Gets the value of the ColorNode::sharpness property
        ///
        /// Gets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::sharpness property
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSharpness ();
        /// Sets the value of the ColorNode::sharpness property
        ///
        /// Sets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSharpness(), sharpnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSharpness (int32_t value);
        /// Checks whether property ColorNode::sharpness is read-only
        ///
        /// Checks whether property ColorNode::sharpness is read-only.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::sharpness is read-only
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool sharpnessIsReadOnly ();
        /// The gain
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t gain;
        #endif
        /// Gets the value of the ColorNode::gain property
        ///
        /// Gets the value of the ColorNode::gain property.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::gain property
        ///
        /// \sa setGain()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getGain ();
        /// Sets the value of the ColorNode::gain property
        ///
        /// Sets the value of the ColorNode::gain property.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getGain(), gainIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGain (int32_t value);
        /// Checks whether property ColorNode::gain is read-only
        ///
        /// Checks whether property ColorNode::gain is read-only.
        ///
        /// The ColorNode::gain property accepts a value ranging
        /// from 1 to 3 with a step of 1. This is a relative value
        /// where increasing values indicate increasing the gain.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::gain is read-only
        ///
        /// \sa setGain()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gainIsReadOnly ();
        /// The exposure (exposure time absolute control).
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t exposure;
        #endif
        /// Gets the value of the ColorNode::exposure property
        ///
        /// Gets the value of the ColorNode::exposure property.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposure property
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getExposure ();
        /// Sets the value of the ColorNode::exposure property
        ///
        /// Sets the value of the ColorNode::exposure property.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposure(), exposureIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposure (int32_t value);
        /// Checks whether property ColorNode::exposure is read-only
        ///
        /// Checks whether property ColorNode::exposure is read-only.
        ///
        /// This is used to specify the length of exposure if the exposure mode
        /// - @see ColorNode::exposureAuto - is set to Manual mode or
        /// ShutterPriority mode.
        ///
        /// The ColorNode::exposure property accepts values in a discrete range [-6; 3] with a
        /// step of 1; these levels reprsent powers of 2 seconds. e.g. -3 == 0.125 seconds . The effective range 
        /// will depend on the actual device implementation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposure is read-only
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureIsReadOnly ();
        /// The auto exposure mode
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ExposureAuto exposureAuto;
        #endif
        /// Gets the value of the ColorNode::exposureAuto property
        ///
        /// Gets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAuto property
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ExposureAuto getExposureAuto ();
        /// Sets the value of the ColorNode::exposureAuto property
        ///
        /// Sets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAuto(), exposureAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAuto (DepthSense::ExposureAuto value);
        /// Checks whether property ColorNode::exposureAuto is read-only
        ///
        /// Checks whether property ColorNode::exposureAuto is read-only.
        ///
        /// The ColorNode::exposureAuto property specifies the auto exposure mode.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAuto is read-only
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoIsReadOnly ();
        /// Whether to enable the auto exposure priority control
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool exposureAutoPriority;
        #endif
        /// Gets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Gets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAutoPriority property
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getExposureAutoPriority ();
        /// Sets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Sets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAutoPriority(), exposureAutoPriorityIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAutoPriority (bool value);
        /// Checks whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// Checks whether property ColorNode::exposureAutoPriority is read-only.
        ///
        /// The ColorNode::exposureAutoPriority property is used to specify
        /// constraints on the exposure time when AutoExposure -  @see ColorNode::exposureAuto
        /// property - is set to Auto mode or ShutterPriority mode. If set to true the frame rate
        /// can be dynamically modified by the device, otherwise the frame rate must remain constant.
        ///
        /// This property is READ-ONLY and will always have a default value set to false due to
        /// device constraints.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoPriorityIsReadOnly ();
        /// Whether to enable automatic white balance.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool whiteBalanceAuto;
        #endif
        /// Gets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Gets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalanceAuto property
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getWhiteBalanceAuto ();
        /// Sets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Sets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalanceAuto(), whiteBalanceAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalanceAuto (bool value);
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceAutoIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::ColorNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::ColorNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
            ::DepthSense::Pointer< uint8_t > colorMap;
            /// The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
            ::DepthSense::Pointer< uint8_t > compressedData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::ColorNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a color sample is captured
        ///
        /// The \c newSampleReceived event is raised when a color sample
        /// is captured.
        ///
        /// \param colorMap The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
        /// \param compressedData The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::ColorNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::ColorNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Color::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when a color sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when a color sample
        /// is captured.      
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data, void (*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::Color::SampleData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Depth
    {
        /// \class SampleData DepthSense.hxx
        /// A class holding all the sample data
        class SampleData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API SampleData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API SampleData (const SampleData& other);
            DEPTHSENSE_API SampleData& operator= (const SampleData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~SampleData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit SampleData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::SampleData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::SampleData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::SampleData type object
            ///
            /// Returns the DepthSense::Depth::SampleData type object
            ///
            /// \return the DepthSense::Depth::SampleData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// The confidence map
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > confidenceMap;
            #endif
            /// Gets the value of the SampleData::confidenceMap property
            ///
            /// Gets the value of the SampleData::confidenceMap property.
            ///
            ///
            /// \return the value of the SampleData::confidenceMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getConfidenceMap ();
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > phaseMap;
            #endif
            /// Gets the value of the SampleData::phaseMap property
            ///
            /// Gets the value of the SampleData::phaseMap property.
            ///
            ///
            /// \return the value of the SampleData::phaseMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getPhaseMap ();
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< int16_t > depthMap;
            #endif
            /// Gets the value of the SampleData::depthMap property
            ///
            /// Gets the value of the SampleData::depthMap property.
            ///
            ///
            /// \return the value of the SampleData::depthMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< int16_t > getDepthMap ();
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< float > depthMapFloatingPoint;
            #endif
            /// Gets the value of the SampleData::depthMapFloatingPoint property
            ///
            /// Gets the value of the SampleData::depthMapFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleData::depthMapFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< float > getDepthMapFloatingPoint ();
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            #endif
            /// Gets the value of the SampleData::vertices property
            ///
            /// Gets the value of the SampleData::vertices property.
            ///
            ///
            /// \return the value of the SampleData::vertices property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::Vertex > getVertices ();
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            #endif
            /// Gets the value of the SampleData::verticesFloatingPoint property
            ///
            /// Gets the value of the SampleData::verticesFloatingPoint property.
            ///
            ///
            /// \return the value of the SampleData::verticesFloatingPoint property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::FPVertex > getVerticesFloatingPoint ();
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) ::DepthSense::Pointer< DepthSense::UV > uvMap;
            #endif
            /// Gets the value of the SampleData::uvMap property
            ///
            /// Gets the value of the SampleData::uvMap property.
            ///
            ///
            /// \return the value of the SampleData::uvMap property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API ::DepthSense::Pointer< DepthSense::UV > getUvMap ();
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
            /// is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Acceleration acceleration;
            #endif
            /// Gets the value of the SampleData::acceleration property
            ///
            /// Gets the value of the SampleData::acceleration property.
            ///
            ///
            /// \return the value of the SampleData::acceleration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Acceleration getAcceleration ();
            /// The system model parameters that were in effect at the time of capture. The coordinate system used 
            /// for the extrinsics is the one specified through \c coordinateSystemType property.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
            #endif
            /// Gets the value of the SampleData::stereoCameraParameters property
            ///
            /// Gets the value of the SampleData::stereoCameraParameters property.
            ///
            ///
            /// \return the value of the SampleData::stereoCameraParameters property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
            /// The camera configuration that was in effect at the time of capture.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::Configuration captureConfiguration;
            #endif
            /// Gets the value of the SampleData::captureConfiguration property
            ///
            /// Gets the value of the SampleData::captureConfiguration property.
            ///
            ///
            /// \return the value of the SampleData::captureConfiguration property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::Configuration getCaptureConfiguration ();
            /// The name of the configuration used to capture the configuration.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::string captureConfigurationName;
            #endif
            private:
            DEPTHSENSE_API ::DSI::String _p_getCaptureConfigurationName ();
            public:
            /// Gets the value of the SampleData::captureConfigurationName property
            ///
            /// Gets the value of the SampleData::captureConfigurationName property.
            ///
            ///
            /// \return the value of the SampleData::captureConfigurationName property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::string getCaptureConfigurationName ()
            {
                std::string retval = _p_getCaptureConfigurationName().unmarshal();
                return retval;
            }
            /// The time of capture of the sample, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfCapture;
            #endif
            /// Gets the value of the SampleData::timeOfCapture property
            ///
            /// Gets the value of the SampleData::timeOfCapture property.
            ///
            ///
            /// \return the value of the SampleData::timeOfCapture property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfCapture ();
            /// the time of arrival of the sample in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the SampleData::timeOfArrival property
            ///
            /// Gets the value of the SampleData::timeOfArrival property.
            ///
            ///
            /// \return the value of the SampleData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            /// The number of dropped samples since the last \c newSampleReceived event was raised.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t droppedSampleCount;
            #endif
            /// Gets the value of the SampleData::droppedSampleCount property
            ///
            /// Gets the value of the SampleData::droppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::droppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getDroppedSampleCount ();
            /// The number of dropped samples since the streaming was started.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t cumulativeDroppedSampleCount;
            #endif
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            /// Gets the value of the SampleData::cumulativeDroppedSampleCount property.
            ///
            ///
            /// \return the value of the SampleData::cumulativeDroppedSampleCount property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getCumulativeDroppedSampleCount ();
            /// The IMU state when the frame was captured.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::IMUData imuData;
            #endif
            /// Gets the value of the SampleData::imuData property
            ///
            /// Gets the value of the SampleData::imuData property.
            ///
            ///
            /// \return the value of the SampleData::imuData property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::IMUData getImuData ();
            /// The exposure histogram
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined). Each bin contains half of the number of pixels of which
            /// exposure falls within the interval specified by the respective bin
            /// edge values
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< uint32_t > exposureHistogram;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< uint32_t > _p_getExposureHistogram ();
            public:
            /// Gets the value of the SampleData::exposureHistogram property
            ///
            /// Gets the value of the SampleData::exposureHistogram property.
            ///
            /// The exposure histogram contains the absolute exposure statistics
            /// within the frame. Exposure values are proportional to the amount
            /// of the total detected photons (from modulated and ambient light
            /// combined). Each bin contains half of the number of pixels of which
            /// exposure falls within the interval specified by the respective bin
            /// edge values
            ///
            /// \return the value of the SampleData::exposureHistogram property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< uint32_t > getExposureHistogram ()
            {
                std::vector< uint32_t > retval = _p_getExposureHistogram().unmarshal();
                return retval;
            }
            /// The \c CoordinateSystemType used
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::CoordinateSystemType coordinateSystemType;
            #endif
            /// Gets the value of the SampleData::coordinateSystemType property
            ///
            /// Gets the value of the SampleData::coordinateSystemType property.
            ///
            ///
            /// \return the value of the SampleData::coordinateSystemType property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::CoordinateSystemType getCoordinateSystemType ();
            /// A mask of the active lasers when the frame was captured
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint32_t activeLasers;
            #endif
            /// Gets the value of the SampleData::activeLasers property
            ///
            /// Gets the value of the SampleData::activeLasers property.
            ///
            ///
            /// \return the value of the SampleData::activeLasers property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint32_t getActiveLasers ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    namespace Depth
    {
        /// \class ButtonEventData DepthSense.hxx
        /// The hardware button corresponding data
        class ButtonEventData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API ButtonEventData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::Depth::IMUData;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API ButtonEventData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API ButtonEventData (const ButtonEventData& other);
            DEPTHSENSE_API ButtonEventData& operator= (const ButtonEventData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~ButtonEventData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit ButtonEventData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::ButtonEventData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::ButtonEventData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::ButtonEventData type object
            ///
            /// Returns the DepthSense::Depth::ButtonEventData type object
            ///
            /// \return the DepthSense::Depth::ButtonEventData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// get the ID of the button for which we triggered the event
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::ButtonID buttonID;
            #endif
            /// Gets the value of the ButtonEventData::buttonID property
            ///
            /// Gets the value of the ButtonEventData::buttonID property.
            ///
            ///
            /// \return the value of the ButtonEventData::buttonID property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::ButtonID getButtonID ();
            /// the time of arrival of the button event in the library, expressed in us.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) uint64_t timeOfArrival;
            #endif
            /// Gets the value of the ButtonEventData::timeOfArrival property
            ///
            /// Gets the value of the ButtonEventData::timeOfArrival property.
            ///
            ///
            /// \return the value of the ButtonEventData::timeOfArrival property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API uint64_t getTimeOfArrival ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
    namespace Depth
    {
    };
    /// \class DepthNode DepthSense.hxx
    /// Represents a depth stream data source
    ///
    /// The DepthNode class allows to capture depth data with the depth sensor
    /// of a given camera device.
    class DepthNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API DepthNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DepthNode (const DepthNode& other);
        DEPTHSENSE_API DepthNode& operator= (const DepthNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::DepthNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::DepthNode type object
        ///
        /// Returns the DepthSense::DepthNode type object
        ///
        /// \return the DepthSense::DepthNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The mode of the camera
        ///
        /// A type enumerating the various operating modes supported
        /// by depth sensors.
        enum CameraMode
        {
            CAMERA_MODE_UNKNOWN = -1,
            CAMERA_MODE_CLOSE_MODE = 0,
            CAMERA_MODE_LONG_RANGE = 1,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String CameraMode_toString_p (CameraMode value);
        #endif
        /// Converts a DepthSense::DepthNode::CameraMode value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::CameraMode, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string CameraMode_toString (CameraMode value)
        {
            return CameraMode_toString_p(value).unmarshal();
        }
        enum OverheatingStatus
        {
            OVERHEATING_STATUS_TEMPERATURE_NORMAL = 0,
            OVERHEATING_STATUS_SOFT_OVERHEATING = 1,
            OVERHEATING_STATUS_HARD_OVERHEATING = 2,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String OverheatingStatus_toString_p (OverheatingStatus value);
        #endif
        /// Converts a DepthSense::DepthNode::OverheatingStatus value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::OverheatingStatus, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string OverheatingStatus_toString (OverheatingStatus value)
        {
            return OverheatingStatus_toString_p(value).unmarshal();
        }
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a depth node
        ///   
        /// The Configuration struct holds the configuration of a depth node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param mode the value of the Configuration::mode field
            /// \param saturation the value of the Configuration::saturation field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::DepthNode::CameraMode mode, bool saturation);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the mode
            DepthSense::DepthNode::CameraMode mode;
            /// whether the saturation is enabled or not
            bool saturation;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// \struct Acceleration DepthSense.hxx
        /// The acceleration returned by the camera
        ///
        /// The Acceleration struct holds the 3 axis acceleration
        /// expressed in g (9.81 m/s²) units. Coordinates are
        /// expressed in the same coordinates as the vertices.
        struct DEPTHSENSE_API Acceleration
        {
            Acceleration ();
            /// Constructs a Acceleration instance
            ///
            /// Constructs a Acceleration instance, initializing the instance fields with the provided values.
            ///
            /// \param x the value of the Acceleration::x field
            /// \param y the value of the Acceleration::y field
            /// \param z the value of the Acceleration::z field
            Acceleration (float x, float y, float z);
            /// the x acceleration
            float x;
            /// the y acceleration
            float y;
            /// the z acceleration
            float z;
            /// Compares two Acceleration instances for equality
            ///
            /// Checks whether the current Acceleration instance is equal to the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Acceleration& other) const;
            /// Compares two Acceleration instances for inequality
            ///
            /// Checks whether the current Acceleration instance is different from the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Acceleration& other) const;
        };
        /// Set the active configuration by name
        ///
        /// When setting a new active configuration, the active calibration will be reset to 0 and the
        /// active configuration will be flushed and replaced with the provided one. The newly active 
        /// configuration will be written immediately on the device.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        ///
        /// \param name the name of the configuration to be used
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfigurationByName (const char* name);
        /// The PRV number of the camera
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t prvNumber;
        #endif
        /// Gets the value of the DepthNode::prvNumber property
        ///
        /// Gets the value of the DepthNode::prvNumber property.
        ///
        /// The DepthNode::prvNumber property specifies the PRV number of the camera.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::prvNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getPrvNumber ();
        /// Set the type of coordinate system to be used
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::CoordinateSystemType coordinateSystemType;
        #endif
        /// Gets the value of the DepthNode::coordinateSystemType property
        ///
        /// Gets the value of the DepthNode::coordinateSystemType property.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::coordinateSystemType property
        ///
        /// \sa setCoordinateSystemType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::CoordinateSystemType getCoordinateSystemType ();
        /// Sets the value of the DepthNode::coordinateSystemType property
        ///
        /// Sets the value of the DepthNode::coordinateSystemType property.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getCoordinateSystemType(), coordinateSystemTypeIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setCoordinateSystemType (DepthSense::CoordinateSystemType value);
        /// Checks whether property DepthNode::coordinateSystemType is read-only
        ///
        /// Checks whether property DepthNode::coordinateSystemType is read-only.
        ///
        /// Set the type of coordinate system to be used. This choice applies to
        /// both the \c vertices and \c verticesFloatingPoint arguments of the \c
        /// newSampleReceived event. By default it uses the \c DepthSense::CoordinateSystemType::LeftHanded
        /// coordinate system type.
        ///
        /// The default value for the \c CoordinateSystemType property is \c DepthSense::COORDINATE_SYSTEM_TYPE_LEFT_HANDED.
        ///
        /// Note that the \c DepthSense::CoordinateSystemType::LeftHanded is deprecated and setting the property
        /// to this value will affect performances.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::coordinateSystemType is read-only
        ///
        /// \sa setCoordinateSystemType()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool coordinateSystemTypeIsReadOnly ();
        /// Whether to enable confidence map computation
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableConfidenceMap;
        #endif
        /// Gets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Gets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableConfidenceMap property
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableConfidenceMap ();
        /// Sets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Sets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableConfidenceMap(), enableConfidenceMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableConfidenceMap (bool value);
        /// Checks whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// Checks whether property DepthNode::enableConfidenceMap is read-only.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableConfidenceMapIsReadOnly ();
        /// Whether to enable phase map computation
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enablePhaseMap;
        #endif
        /// Gets the value of the DepthNode::enablePhaseMap property
        ///
        /// Gets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enablePhaseMap property
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnablePhaseMap ();
        /// Sets the value of the DepthNode::enablePhaseMap property
        ///
        /// Sets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnablePhaseMap(), enablePhaseMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnablePhaseMap (bool value);
        /// Checks whether property DepthNode::enablePhaseMap is read-only
        ///
        /// Checks whether property DepthNode::enablePhaseMap is read-only.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enablePhaseMap is read-only
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enablePhaseMapIsReadOnly ();
        /// Whether to enable fixed point depth map computation
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMap;
        #endif
        /// Gets the value of the DepthNode::enableDepthMap property
        ///
        /// Gets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMap property
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMap ();
        /// Sets the value of the DepthNode::enableDepthMap property
        ///
        /// Sets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMap(), enableDepthMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMap (bool value);
        /// Checks whether property DepthNode::enableDepthMap is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMap is read-only.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMap is read-only
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapIsReadOnly ();
        /// Whether to enable floating point depth map computation
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMapFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMapFloatingPoint ();
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMapFloatingPoint(), enableDepthMapFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMapFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapFloatingPointIsReadOnly ();
        /// Whether to enable fixed point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVertices;
        #endif
        /// Gets the value of the DepthNode::enableVertices property
        ///
        /// Gets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVertices property
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVertices ();
        /// Sets the value of the DepthNode::enableVertices property
        ///
        /// Sets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVertices(), enableVerticesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVertices (bool value);
        /// Checks whether property DepthNode::enableVertices is read-only
        ///
        /// Checks whether property DepthNode::enableVertices is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVertices is read-only
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesIsReadOnly ();
        /// Whether to enable floating point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVerticesFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVerticesFloatingPoint ();
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVerticesFloatingPoint(), enableVerticesFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVerticesFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesFloatingPointIsReadOnly ();
        /// Whether the depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMap3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMap3Planes property
        ///
        /// Gets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMap3Planes property
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMap3Planes ();
        /// Sets the value of the DepthNode::depthMap3Planes property
        ///
        /// Sets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMap3Planes(), depthMap3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMap3Planes (bool value);
        /// Checks whether property DepthNode::depthMap3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMap3Planes is read-only.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMap3Planes is read-only
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMap3PlanesIsReadOnly ();
        /// Whether the floating point depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMapFloatingPoint3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMapFloatingPoint3Planes ();
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMapFloatingPoint3Planes(), depthMapFloatingPoint3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMapFloatingPoint3Planes (bool value);
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMapFloatingPoint3PlanesIsReadOnly ();
        /// Whether to enable UV map computation
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableUvMap;
        #endif
        /// Gets the value of the DepthNode::enableUvMap property
        ///
        /// Gets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableUvMap property
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableUvMap ();
        /// Sets the value of the DepthNode::enableUvMap property
        ///
        /// Sets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableUvMap(), enableUvMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableUvMap (bool value);
        /// Checks whether property DepthNode::enableUvMap is read-only
        ///
        /// Checks whether property DepthNode::enableUvMap is read-only.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableUvMap is read-only
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableUvMapIsReadOnly ();
        /// Whether to enable the accelerometer data
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableAccelerometer;
        #endif
        /// Gets the value of the DepthNode::enableAccelerometer property
        ///
        /// Gets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableAccelerometer property
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableAccelerometer ();
        /// Sets the value of the DepthNode::enableAccelerometer property
        ///
        /// Sets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableAccelerometer(), enableAccelerometerIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableAccelerometer (bool value);
        /// Checks whether property DepthNode::enableAccelerometer is read-only
        ///
        /// Checks whether property DepthNode::enableAccelerometer is read-only.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableAccelerometer is read-only
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableAccelerometerIsReadOnly ();
        #ifdef DEPTHSENSE_DOC
        @property bool _noFan;
        #endif
        /// Gets the value of the DepthNode::_noFan property
        ///
        /// Gets the value of the DepthNode::_noFan property.
        ///
        /// \return the value of the DepthNode::_noFan property
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool get_noFan ();
        /// Sets the value of the DepthNode::_noFan property
        ///
        /// Sets the value of the DepthNode::_noFan property.
        ///
        /// \param value the value to set
        ///
        /// \sa get_noFan(), _noFanIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void set_noFan (bool value);
        /// Checks whether property DepthNode::_noFan is read-only
        ///
        /// Checks whether property DepthNode::_noFan is read-only.
        ///
        /// \return whether property DepthNode::_noFan is read-only
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool _noFanIsReadOnly ();
        /// Specify the confidence threshold
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t confidenceThreshold;
        #endif
        /// Gets the value of the DepthNode::confidenceThreshold property
        ///
        /// Gets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::confidenceThreshold property
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getConfidenceThreshold ();
        /// Sets the value of the DepthNode::confidenceThreshold property
        ///
        /// Sets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfidenceThreshold(), confidenceThresholdIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfidenceThreshold (int32_t value);
        /// Checks whether property DepthNode::confidenceThreshold is read-only
        ///
        /// Checks whether property DepthNode::confidenceThreshold is read-only.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::confidenceThreshold is read-only
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool confidenceThresholdIsReadOnly ();
        /// Specify the illumination level
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t illuminationLevel;
        #endif
        /// Gets the value of the DepthNode::illuminationLevel property
        ///
        /// Gets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::illuminationLevel property
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getIlluminationLevel ();
        /// Sets the value of the DepthNode::illuminationLevel property
        ///
        /// Sets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getIlluminationLevel(), illuminationLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException the property is not supported by the node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setIlluminationLevel (int32_t value);
        /// Checks whether property DepthNode::illuminationLevel is read-only
        ///
        /// Checks whether property DepthNode::illuminationLevel is read-only.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::illuminationLevel is read-only
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool illuminationLevelIsReadOnly ();
        /// Whether to enable denoising
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDenoising;
        #endif
        /// Gets the value of the DepthNode::enableDenoising property
        ///
        /// Gets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDenoising property
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDenoising ();
        /// Sets the value of the DepthNode::enableDenoising property
        ///
        /// Sets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDenoising(), enableDenoisingIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDenoising (bool value);
        /// Checks whether property DepthNode::enableDenoising is read-only
        ///
        /// Checks whether property DepthNode::enableDenoising is read-only.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDenoising is read-only
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDenoisingIsReadOnly ();
        /// The node configuration
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::DepthNode::Configuration configuration;
        #endif
        /// Gets the value of the DepthNode::configuration property
        ///
        /// Gets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::Configuration getConfiguration ();
        /// Sets the value of the DepthNode::configuration property
        ///
        /// Sets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::DepthNode::Configuration value);
        /// Checks whether property DepthNode::configuration is read-only
        ///
        /// Checks whether property DepthNode::configuration is read-only.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The DepthNode::configurations property specifies the list
        /// of supported node configurations.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::DepthNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::DepthNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the DepthNode::configurations property
        ///
        /// Gets the value of the DepthNode::configurations property.
        ///
        ///
        /// \return the value of the DepthNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::DepthNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::DepthNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The depth sensor range
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        #ifdef DEPTHSENSE_DOC
        @property(readonly) float range;
        #endif
        /// Gets the value of the DepthNode::range property
        ///
        /// Gets the value of the DepthNode::range property.
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        ///
        /// \return the value of the DepthNode::range property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getRange ();
        /// The IMU firmware version
        ///
        /// The DepthNode::imuFwVersion property specifies the version of the current IMU board.
        /// The version is as given by the IMU (See IMU meta data documentation for more details).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) uint32_t imuFwVersion;
        #endif
        /// Gets the value of the DepthNode::imuFwVersion property
        ///
        /// Gets the value of the DepthNode::imuFwVersion property.
        ///
        /// The DepthNode::imuFwVersion property specifies the version of the current IMU board.
        /// The version is as given by the IMU (See IMU meta data documentation for more details).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::imuFwVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API uint32_t getImuFwVersion ();
        /// The list of IMU board leds color
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property std::vector< uint32_t > imuLedsColor;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< uint32_t > _p_getImuLedsColor ();
        public:
        /// Gets the value of the DepthNode::imuLedsColor property
        ///
        /// Gets the value of the DepthNode::imuLedsColor property.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::imuLedsColor property
        ///
        /// \sa setImuLedsColor()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< uint32_t > getImuLedsColor ()
        {
            std::vector< uint32_t > retval = _p_getImuLedsColor().unmarshal();
            return retval;
        }
        private:
        DEPTHSENSE_API void _p_setImuLedsColor (::DSI::Vector< uint32_t > value);
        public:
        /// Sets the value of the DepthNode::imuLedsColor property
        ///
        /// Sets the value of the DepthNode::imuLedsColor property.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getImuLedsColor(), imuLedsColorIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException the property is not supported by the node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        void setImuLedsColor (std::vector< uint32_t > value)
        {
            ::DSI::Vector< uint32_t > _p_value = DSI::Vector< uint32_t >::marshal(value);
            _p_setImuLedsColor(_p_value);
        }
        /// Checks whether property DepthNode::imuLedsColor is read-only
        ///
        /// Checks whether property DepthNode::imuLedsColor is read-only.
        ///
        /// The DepthNode::imuLedsColor property specifies the current color of each led of the IMU board, expressed in RGB, 8 bits per channel
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::imuLedsColor is read-only
        ///
        /// \sa setImuLedsColor()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool imuLedsColorIsReadOnly ();
        /// Return the list of name of known configurations
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< std::string > configurationList;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< ::DSI::String > _p_getConfigurationList ();
        public:
        /// Gets the value of the DepthNode::configurationList property
        ///
        /// Gets the value of the DepthNode::configurationList property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        ///
        /// \return the value of the DepthNode::configurationList property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< std::string > getConfigurationList ()
        {
            ::DSI::Vector< ::DSI::String > _tmp18 = _p_getConfigurationList();
            std::vector< std::string > retval;
            int32_t _tmp19 = (int32_t) _tmp18.size();
            for (int _i = 0; _i < _tmp19; _i++)
            {
                retval.push_back(_tmp18[_i].unmarshal());
            }
            return retval;
        }
        /// Return the name of the current active configuration
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string configurationName;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getConfigurationName ();
        public:
        /// Gets the value of the DepthNode::configurationName property
        ///
        /// Gets the value of the DepthNode::configurationName property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        ///
        /// \return the value of the DepthNode::configurationName property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getConfigurationName ()
        {
            std::string retval = _p_getConfigurationName().unmarshal();
            return retval;
        }
        /// The high sensitivity mode
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityMode;
        #endif
        /// Gets the value of the DepthNode::highSensitivityMode property
        ///
        /// Gets the value of the DepthNode::highSensitivityMode property.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityMode property
        ///
        /// \sa setHighSensitivityMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityMode ();
        /// Sets the value of the DepthNode::highSensitivityMode property
        ///
        /// Sets the value of the DepthNode::highSensitivityMode property.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityMode(), highSensitivityModeIsReadOnly()
        ///
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::ArgumentException the value passed as argument is not valid
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityMode (int32_t value);
        /// Checks whether property DepthNode::highSensitivityMode is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityMode is read-only.
        ///
        /// The DepthNode::highSensitivityMode property controls the
        /// high sensitivity mode
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityMode is read-only
        ///
        /// \sa setHighSensitivityMode()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeIsReadOnly ();
        /// Specify the high sensitivity mode parameter 1
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityModeParameter1;
        #endif
        /// Gets the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// Gets the value of the DepthNode::highSensitivityModeParameter1 property.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// \sa setHighSensitivityModeParameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityModeParameter1 ();
        /// Sets the value of the DepthNode::highSensitivityModeParameter1 property
        ///
        /// Sets the value of the DepthNode::highSensitivityModeParameter1 property.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityModeParameter1(), highSensitivityModeParameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityModeParameter1 (int32_t value);
        /// Checks whether property DepthNode::highSensitivityModeParameter1 is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityModeParameter1 is read-only.
        ///
        /// The DepthNode::highSensitivityModeParameter1 property specifies the
        /// high sensitivity mode parameter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityModeParameter1 is read-only
        ///
        /// \sa setHighSensitivityModeParameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeParameter1IsReadOnly ();
        /// Specify the high sensitivity mode parameter 2
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t highSensitivityModeParameter2;
        #endif
        /// Gets the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// Gets the value of the DepthNode::highSensitivityModeParameter2 property.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// \sa setHighSensitivityModeParameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHighSensitivityModeParameter2 ();
        /// Sets the value of the DepthNode::highSensitivityModeParameter2 property
        ///
        /// Sets the value of the DepthNode::highSensitivityModeParameter2 property.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHighSensitivityModeParameter2(), highSensitivityModeParameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHighSensitivityModeParameter2 (int32_t value);
        /// Checks whether property DepthNode::highSensitivityModeParameter2 is read-only
        ///
        /// Checks whether property DepthNode::highSensitivityModeParameter2 is read-only.
        ///
        /// The DepthNode::highSensitivityModeParameter2 property specifies the
        /// high sensitivity mode parameter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::highSensitivityModeParameter2 is read-only
        ///
        /// \sa setHighSensitivityModeParameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool highSensitivityModeParameter2IsReadOnly ();
        /// Whether to enable filter 1
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter1;
        #endif
        /// Gets the value of the DepthNode::enableFilter1 property
        ///
        /// Gets the value of the DepthNode::enableFilter1 property.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter1 property
        ///
        /// \sa setEnableFilter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter1 ();
        /// Sets the value of the DepthNode::enableFilter1 property
        ///
        /// Sets the value of the DepthNode::enableFilter1 property.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter1(), enableFilter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter1 (bool value);
        /// Checks whether property DepthNode::enableFilter1 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter1 is read-only.
        ///
        /// Specifies whether to enable filter 1
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter1 is read-only
        ///
        /// \sa setEnableFilter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter1IsReadOnly ();
        /// Whether to enable filter 2
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter2;
        #endif
        /// Gets the value of the DepthNode::enableFilter2 property
        ///
        /// Gets the value of the DepthNode::enableFilter2 property.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter2 property
        ///
        /// \sa setEnableFilter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter2 ();
        /// Sets the value of the DepthNode::enableFilter2 property
        ///
        /// Sets the value of the DepthNode::enableFilter2 property.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter2(), enableFilter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter2 (bool value);
        /// Checks whether property DepthNode::enableFilter2 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter2 is read-only.
        ///
        /// Specifies whether to enable filter 2
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter2 is read-only
        ///
        /// \sa setEnableFilter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter2IsReadOnly ();
        /// Whether to enable filter 3
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter3;
        #endif
        /// Gets the value of the DepthNode::enableFilter3 property
        ///
        /// Gets the value of the DepthNode::enableFilter3 property.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter3 property
        ///
        /// \sa setEnableFilter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter3 ();
        /// Sets the value of the DepthNode::enableFilter3 property
        ///
        /// Sets the value of the DepthNode::enableFilter3 property.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter3(), enableFilter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter3 (bool value);
        /// Checks whether property DepthNode::enableFilter3 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter3 is read-only.
        ///
        /// Specifies whether to enable filter 3
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter3 is read-only
        ///
        /// \sa setEnableFilter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter3IsReadOnly ();
        /// Whether to enable filter 4
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter4;
        #endif
        /// Gets the value of the DepthNode::enableFilter4 property
        ///
        /// Gets the value of the DepthNode::enableFilter4 property.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter4 property
        ///
        /// \sa setEnableFilter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter4 ();
        /// Sets the value of the DepthNode::enableFilter4 property
        ///
        /// Sets the value of the DepthNode::enableFilter4 property.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter4(), enableFilter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter4 (bool value);
        /// Checks whether property DepthNode::enableFilter4 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter4 is read-only.
        ///
        /// Specifies whether to enable filter 4
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter4 is read-only
        ///
        /// \sa setEnableFilter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter4IsReadOnly ();
        /// Whether to enable filter 8
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter8;
        #endif
        /// Gets the value of the DepthNode::enableFilter8 property
        ///
        /// Gets the value of the DepthNode::enableFilter8 property.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter8 property
        ///
        /// \sa setEnableFilter8()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter8 ();
        /// Sets the value of the DepthNode::enableFilter8 property
        ///
        /// Sets the value of the DepthNode::enableFilter8 property.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter8(), enableFilter8IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter8 (bool value);
        /// Checks whether property DepthNode::enableFilter8 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter8 is read-only.
        ///
        /// Specifies whether to enable filter 8
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter8 is read-only
        ///
        /// \sa setEnableFilter8()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter8IsReadOnly ();
        /// Whether to enable filter 9
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableFilter9;
        #endif
        /// Gets the value of the DepthNode::enableFilter9 property
        ///
        /// Gets the value of the DepthNode::enableFilter9 property.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableFilter9 property
        ///
        /// \sa setEnableFilter9()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableFilter9 ();
        /// Sets the value of the DepthNode::enableFilter9 property
        ///
        /// Sets the value of the DepthNode::enableFilter9 property.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableFilter9(), enableFilter9IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableFilter9 (bool value);
        /// Checks whether property DepthNode::enableFilter9 is read-only
        ///
        /// Checks whether property DepthNode::enableFilter9 is read-only.
        ///
        /// Specifies whether to enable filter 9
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableFilter9 is read-only
        ///
        /// \sa setEnableFilter9()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableFilter9IsReadOnly ();
        /// Specify the parameter 1 of filter 1
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter1 property.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter1 property
        ///
        /// \sa setFilter1Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter1 ();
        /// Sets the value of the DepthNode::filter1Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter1 property.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter1(), filter1Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter1 is read-only.
        ///
        /// The DepthNode::filter1Parameter1 property specifies the
        /// parameter 1 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter1 is read-only
        ///
        /// \sa setFilter1Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 1
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter2 property.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter2 property
        ///
        /// \sa setFilter1Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter2 ();
        /// Sets the value of the DepthNode::filter1Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter2 property.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter2(), filter1Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter2 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter2 is read-only.
        ///
        /// The DepthNode::filter1Parameter2 property specifies the
        /// parameter 2 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter2 is read-only
        ///
        /// \sa setFilter1Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 1
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter3 property.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter3 property
        ///
        /// \sa setFilter1Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter3 ();
        /// Sets the value of the DepthNode::filter1Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter3 property.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter3(), filter1Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter3 is read-only.
        ///
        /// The DepthNode::filter1Parameter3 property specifies the
        /// parameter 3 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter3 is read-only
        ///
        /// \sa setFilter1Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 1
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter1Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter1Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter1Parameter4 property.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter1Parameter4 property
        ///
        /// \sa setFilter1Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter1Parameter4 ();
        /// Sets the value of the DepthNode::filter1Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter1Parameter4 property.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter1Parameter4(), filter1Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter1Parameter4 (int32_t value);
        /// Checks whether property DepthNode::filter1Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter1Parameter4 is read-only.
        ///
        /// The DepthNode::filter1Parameter4 property specifies the
        /// parameter 4 of filter 1.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter1Parameter4 is read-only
        ///
        /// \sa setFilter1Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter1Parameter4IsReadOnly ();
        /// Specify the parameter 1 of filter 2
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter2Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter2Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter2Parameter1 property.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter2Parameter1 property
        ///
        /// \sa setFilter2Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter2Parameter1 ();
        /// Sets the value of the DepthNode::filter2Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter2Parameter1 property.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter2Parameter1(), filter2Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter2Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter2Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter2Parameter1 is read-only.
        ///
        /// The DepthNode::filter2Parameter1 property specifies the
        /// parameter 1 of filter 2.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter2Parameter1 is read-only
        ///
        /// \sa setFilter2Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter2Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 3
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter3Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter1 property.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter1 property
        ///
        /// \sa setFilter3Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter3Parameter1 ();
        /// Sets the value of the DepthNode::filter3Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter1 property.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter1(), filter3Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter1 (float value);
        /// Checks whether property DepthNode::filter3Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter1 is read-only.
        ///
        /// The DepthNode::filter3Parameter1 property specifies the
        /// parameter 1 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter1 is read-only
        ///
        /// \sa setFilter3Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 3
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter3Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter2 property.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter2 property
        ///
        /// \sa setFilter3Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter3Parameter2 ();
        /// Sets the value of the DepthNode::filter3Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter2 property.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter2(), filter3Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter2 (float value);
        /// Checks whether property DepthNode::filter3Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter2 is read-only.
        ///
        /// The DepthNode::filter3Parameter2 property specifies the
        /// parameter 2 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter2 is read-only
        ///
        /// \sa setFilter3Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 3
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter3Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter3Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter3Parameter3 property.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter3Parameter3 property
        ///
        /// \sa setFilter3Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter3Parameter3 ();
        /// Sets the value of the DepthNode::filter3Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter3Parameter3 property.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter3Parameter3(), filter3Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter3Parameter3 (int32_t value);
        /// Checks whether property DepthNode::filter3Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter3Parameter3 is read-only.
        ///
        /// The DepthNode::filter3Parameter3 property specifies the
        /// parameter 3 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter3Parameter3 is read-only
        ///
        /// \sa setFilter3Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter3Parameter3IsReadOnly ();
        /// Specify the parameter 1 of filter 4
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter4Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter4Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter4Parameter1 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter4Parameter1 property
        ///
        /// \sa setFilter4Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter4Parameter1 ();
        /// Sets the value of the DepthNode::filter4Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter4Parameter1 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter4Parameter1(), filter4Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter4Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter4Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter4Parameter1 is read-only.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 1 of filter 4.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter4Parameter1 is read-only
        ///
        /// \sa setFilter4Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter4Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 8
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter8Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter8Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter8Parameter1 property.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter8Parameter1 property
        ///
        /// \sa setFilter8Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter8Parameter1 ();
        /// Sets the value of the DepthNode::filter8Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter8Parameter1 property.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter8Parameter1(), filter8Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter8Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter8Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter8Parameter1 is read-only.
        ///
        /// The DepthNode::filter8Parameter1 property specifies the
        /// parameter 1 of filter 8.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter8Parameter1 is read-only
        ///
        /// \sa setFilter8Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter8Parameter1IsReadOnly ();
        /// Specify the parameter 1 of filter 9
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t filter9Parameter1;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter1 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter1 property.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter1 property
        ///
        /// \sa setFilter9Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getFilter9Parameter1 ();
        /// Sets the value of the DepthNode::filter9Parameter1 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter1 property.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter1(), filter9Parameter1IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter1 (int32_t value);
        /// Checks whether property DepthNode::filter9Parameter1 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter1 is read-only.
        ///
        /// The DepthNode::filter9Parameter1 property specifies the
        /// parameter 1 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter1 is read-only
        ///
        /// \sa setFilter9Parameter1()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter1IsReadOnly ();
        /// Specify the parameter 2 of filter 9
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter2;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter2 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter2 property.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter2 property
        ///
        /// \sa setFilter9Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter2 ();
        /// Sets the value of the DepthNode::filter9Parameter2 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter2 property.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter2(), filter9Parameter2IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter2 (float value);
        /// Checks whether property DepthNode::filter9Parameter2 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter2 is read-only.
        ///
        /// The DepthNode::filter9Parameter2 property specifies the
        /// parameter 2 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter2 is read-only
        ///
        /// \sa setFilter9Parameter2()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter2IsReadOnly ();
        /// Specify the parameter 3 of filter 9
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter3;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter3 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter3 property.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter3 property
        ///
        /// \sa setFilter9Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter3 ();
        /// Sets the value of the DepthNode::filter9Parameter3 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter3 property.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter3(), filter9Parameter3IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter3 (float value);
        /// Checks whether property DepthNode::filter9Parameter3 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter3 is read-only.
        ///
        /// The DepthNode::filter9Parameter3 property specifies the
        /// parameter 9 of filter 3.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter3 is read-only
        ///
        /// \sa setFilter9Parameter3()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter3IsReadOnly ();
        /// Specify the parameter 4 of filter 9
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property float filter9Parameter4;
        #endif
        /// Gets the value of the DepthNode::filter9Parameter4 property
        ///
        /// Gets the value of the DepthNode::filter9Parameter4 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::filter9Parameter4 property
        ///
        /// \sa setFilter9Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getFilter9Parameter4 ();
        /// Sets the value of the DepthNode::filter9Parameter4 property
        ///
        /// Sets the value of the DepthNode::filter9Parameter4 property.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getFilter9Parameter4(), filter9Parameter4IsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setFilter9Parameter4 (float value);
        /// Checks whether property DepthNode::filter9Parameter4 is read-only
        ///
        /// Checks whether property DepthNode::filter9Parameter4 is read-only.
        ///
        /// The DepthNode::filter4Parameter1 property specifies the
        /// parameter 4 of filter 9.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::filter9Parameter4 is read-only
        ///
        /// \sa setFilter9Parameter4()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool filter9Parameter4IsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::DepthNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the confidence map
            ::DepthSense::Pointer< int16_t > confidenceMap;
            /// The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            ::DepthSense::Pointer< int16_t > phaseMap;
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            ::DepthSense::Pointer< int16_t > depthMap;
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            ::DepthSense::Pointer< float > depthMapFloatingPoint;
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
            ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            ::DepthSense::Pointer< DepthSense::UV > uvMap;
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
            DepthSense::DepthNode::Acceleration acceleration;
            /// the system model parameters that were in effect at the time of capture. The coordinate system used 
            DepthSense::StereoCameraParameters stereoCameraParameters;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::DepthNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in us
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in us
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceived event is raised when a depth sample
        /// is captured.
        ///
        /// \param confidenceMap the confidence map
        /// \param phaseMap The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
        /// \param depthMap The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
        /// \param depthMapFloatingPoint The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
        /// \param vertices The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param verticesFloatingPoint The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param uvMap The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
        /// \param acceleration The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used 
        /// is the one specified through \c coordinateSystemType property.
        /// \param stereoCameraParameters the system model parameters that were in effect at the time of capture. The coordinate system used 
        /// for the extrinsics is the one specified through \c coordinateSystemType property.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in us
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in us
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2 PI[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002. The coordinate system used </td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0. The coordinate system used </td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz. The coordinate system used </td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture. The coordinate system used </td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in us</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in us</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        /// \struct NewSampleReceived2Data DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceived2Event arguments
        ///
        /// The NewSampleReceived2Data struct holds the DepthSense::DepthNode::NewSampleReceived2Event parameters and is passed to callbacks connected to that event.
        struct NewSampleReceived2Data
        {
            DepthSense::Depth::SampleData data;
        };
        /// \class NewSampleReceived2Event DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceived2 event is raised when a depth sample
        /// is captured.
        class NewSampleReceived2Event : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>
        {
            private:
            NewSampleReceived2Event (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    _func(obj, data.data, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceived2Data data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data)>::_method))(obj, data.data);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceived2Data>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceived2Data data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceived2Data, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::SampleData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceived2Data>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived2 event object
        ///
        /// Returns a reference to the \c newSampleReceived2 event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived2 event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceived2Event& newSampleReceived2Event () const;
        /// \struct ButtonPressedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::ButtonPressedEvent arguments
        ///
        /// The ButtonPressedData struct holds the DepthSense::DepthNode::ButtonPressedEvent parameters and is passed to callbacks connected to that event.
        struct ButtonPressedData
        {
            DepthSense::Depth::ButtonEventData buttonEventData;
        };
        /// \class ButtonPressedEvent DepthSense.hxx
        /// Event raised when a button is pressed.
        ///
        /// The \c buttonPressed event is raised when a button is pressed on the camera.
        ///
        /// \param buttoneventData data assciated with the button event - the button ID
        ///
        class ButtonPressedEvent : public DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>
        {
            private:
            ButtonPressedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    _func(obj, data.buttonEventData);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonPressedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    _func(obj, data.buttonEventData, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonPressedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonPressedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_method))(obj, data.buttonEventData);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonPressedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonPressedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonPressedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonPressedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonPressedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonPressedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonPressedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonPressedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c buttonPressed event object
        ///
        /// Returns a reference to the \c buttonPressed event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c buttonPressed event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::ButtonPressedEvent& buttonPressedEvent () const;
        /// \struct ButtonReleasedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::ButtonReleasedEvent arguments
        ///
        /// The ButtonReleasedData struct holds the DepthSense::DepthNode::ButtonReleasedEvent parameters and is passed to callbacks connected to that event.
        struct ButtonReleasedData
        {
            DepthSense::Depth::ButtonEventData buttonEventData;
        };
        /// \class ButtonReleasedEvent DepthSense.hxx
        /// Event raised when a button is release.
        ///
        /// The \c buttonPressed event is raised when a button is released on the camera.
        ///
        /// \param buttoneventData data assciated with the button event - the button ID
        ///
        class ButtonReleasedEvent : public DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>
        {
            private:
            ButtonReleasedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    _func(obj, data.buttonEventData);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, ButtonReleasedData, void (*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    _func(obj, data.buttonEventData, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, ButtonReleasedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, ButtonReleasedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData)>::_method))(obj, data.buttonEventData);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonReleasedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, ButtonReleasedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonReleasedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, ButtonReleasedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonReleasedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::ButtonReleasedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, ButtonReleasedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p buttonEventData</td><td></td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::Depth::ButtonEventData buttonEventData))
            {
                DepthSense::Event<DepthSense::DepthNode, ButtonReleasedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c buttonReleased event object
        ///
        /// Returns a reference to the \c buttonReleased event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c buttonReleased event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::ButtonReleasedEvent& buttonReleasedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class UnsupportedNode DepthSense.hxx
    /// Represents an unsupported stream data source
    ///   
    /// The UnsupportedNode class allows to have some information about 
    /// an unsupported device. This node can not be registered neither controlled.
    class UnsupportedNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API UnsupportedNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API UnsupportedNode (const UnsupportedNode& other);
        DEPTHSENSE_API UnsupportedNode& operator= (const UnsupportedNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::UnsupportedNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// \return the DepthSense::UnsupportedNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The reason the node is unsupported
        ///   
        /// The UnsupportedNode::reason property specifies the reason
        /// why the node is not supported.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string reason;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getReason ();
        public:
        /// Gets the value of the UnsupportedNode::reason property
        ///
        /// Gets the value of the UnsupportedNode::reason property.
        ///
        ///
        /// \return the value of the UnsupportedNode::reason property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getReason ()
        {
            std::string retval = _p_getReason().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Device DepthSense.hxx
    /// Represents a camera device
    ///   
    /// The Device class represents a physical camera device connected
    /// to the host. It exposes device information (serial number,
    /// model and so on) and contains a number of stream data sources
    /// designated as \em nodes.
    class Device
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Device (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Device (const Device& other);
        DEPTHSENSE_API Device& operator= (const Device& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Device (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Device& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Device type object
        ///
        /// Returns the DepthSense::Device type object
        ///
        /// \return the DepthSense::Device type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The camera model
        ///
        /// An enumeration comprising all the camera models supported by
        /// DepthSense SDK.
        enum Model
        {
            MODEL_UNKNOWN = 0,/*!< unknown model */
            MODEL_DS320 = 1,/*!< DepthSense 320 */
            MODEL_DS325 = 2,/*!< DepthSense 325 */
            MODEL_DS311 = 3,/*!< DepthSense 311 */
            MODEL_GENERIC = 4,/*!< Generic */
            MODEL_VF0780 = 5,/*!< DepthSense 325 */
            MODEL_TICDK = 7,/*!< TI-CDK */
            MODEL_DS536 = 8,/*!< DS536 */
            MODEL_SKCDK = 9,/*!< SK-CDK */
            MODEL_DS326 = 10,/*!< DepthSense 326 */
            MODEL_IMP_DS327 = 11,/*!< Imprivata DS327 */
            MODEL_DS536A = 12,/*!< DS536A */
            MODEL_DS536B = 13,/*!< DS536B */
            MODEL_DS325B = 14,/*!< DS325B */
            MODEL_STEREOLR = 129,/*!< StereoLR */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Model_toString_p (Model value);
        #endif
        /// Converts a DepthSense::Device::Model value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Device::Model, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Model_toString (Model value)
        {
            return Model_toString_p(value).unmarshal();
        }
        /// A bitmask of capabilities supported by the camera
        ///   
        /// A bitmask of capabilities supported by the camera.
        enum Capabilities
        {
            CAPABILITIES_COLOR = 1,/*!< the camera supports color streaming */
            CAPABILITIES_DEPTH = 2,/*!< the camera supports depth streaming */
            CAPABILITIES_AUDIO = 4,/*!< the camera supports audio streaming */
            CAPABILITIES_ACCELEROMETER = 8,/*!< the camera has an accelerometer */
            CAPABILITIES_IMU = 16,/*!< The camera has an IMU */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Capabilities_toString_p (Capabilities value);
        #endif
        /// Converts a DepthSense::Device::Capabilities value to a string
        ///
        /// Converts the provided bitmask to a string.
        ///
        /// \param value the bitmask to convert
        ///
        /// \return a string of the form <tt>"Flag1 | Flag2 | Flag3"</tt>; unknown bits are omitted from the representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Capabilities_toString (Capabilities value)
        {
            return Capabilities_toString_p(value).unmarshal();
        }
        /// The camera serial number
        ///   
        /// The Device::serialNumber property specifies the serial
        /// number of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Device::serialNumber property
        ///
        /// Gets the value of the Device::serialNumber property.
        ///
        ///
        /// \return the value of the Device::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The camera model
        ///   
        /// The Device::model property specifies the model of the
        /// current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Model model;
        #endif
        /// Gets the value of the Device::model property
        ///
        /// Gets the value of the Device::model property.
        ///
        ///
        /// \return the value of the Device::model property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Model getModel ();
        /// The TOF controller firmware version
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t tofControllerVersion;
        #endif
        /// Gets the value of the Device::tofControllerVersion property
        ///
        /// Gets the value of the Device::tofControllerVersion property.
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::tofControllerVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getTofControllerVersion ();
        /// The USB backend firmware version
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t usbBackendVersion;
        #endif
        /// Gets the value of the Device::usbBackendVersion property
        ///
        /// Gets the value of the Device::usbBackendVersion property.
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::usbBackendVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getUsbBackendVersion ();
        /// The camera overheating status
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheating;
        #endif
        /// Gets the value of the Device::overheating property
        ///
        /// Gets the value of the Device::overheating property.
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheating property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheating ();
        /// The camera overheated status
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheated;
        #endif
        /// Gets the value of the Device::overheated property
        ///
        /// Gets the value of the Device::overheated property.
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheated property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheated ();
        /// The camera capabilities
        ///   
        /// The Device::capabilities property specifies the
        /// capabilities of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Capabilities capabilities;
        #endif
        /// Gets the value of the Device::capabilities property
        ///
        /// Gets the value of the Device::capabilities property.
        ///
        ///
        /// \return the value of the Device::capabilities property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Capabilities getCapabilities ();
        /// The stream data sources
        ///   
        /// The Device::nodes property specifies the stream data
        /// sources exposed by the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > nodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getNodes ();
        public:
        /// Gets the value of the Device::nodes property
        ///
        /// Gets the value of the Device::nodes property.
        ///
        ///
        /// \return the value of the Device::nodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getNodes().unmarshal();
            return retval;
        }
        /// The system model parameters
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters. The coordinate system used 
        /// for the extrinsics is the one specified through \c DepthNode::coordinateSystemType property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
        #endif
        /// Gets the value of the Device::stereoCameraParameters property
        ///
        /// Gets the value of the Device::stereoCameraParameters property.
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters. The coordinate system used 
        /// for the extrinsics is the one specified through \c DepthNode::coordinateSystemType property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::stereoCameraParameters property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
        /// \struct NodeAddedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeAddedEvent arguments
        ///
        /// The NodeAddedData struct holds the DepthSense::Device::NodeAddedEvent parameters and is passed to callbacks connected to that event.
        struct NodeAddedData
        {
            /// the node that was attached to the current device
            DepthSense::Node node;
        };
        /// \class NodeAddedEvent DepthSense.hxx
        /// Event raised when a node is attached to the current device
        ///   
        /// The \c nodeAdded event is raised when a stream data source
        /// is attached to the current device.
        ///
        /// \param node the node that was attached to the current device
        ///
        /// \sa NodeRemovedEvent
        class NodeAddedEvent : public DepthSense::Event<DepthSense::Device, NodeAddedData>
        {
            private:
            NodeAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeAdded event object
        ///
        /// Returns a reference to the \c nodeAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeAddedEvent& nodeAddedEvent () const;
        /// \struct NodeRemovedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeRemovedEvent arguments
        ///
        /// The NodeRemovedData struct holds the DepthSense::Device::NodeRemovedEvent parameters and is passed to callbacks connected to that event.
        struct NodeRemovedData
        {
            /// the node that was detached from the current device
            DepthSense::Node node;
        };
        /// \class NodeRemovedEvent DepthSense.hxx
        /// Event raised when a node is detached from the current device
        ///   
        /// The \c nodeRemoved event is raised when a stream data source
        /// is detached from the current device.
        ///
        /// \param node the node that was detached from the current device
        ///
        /// \sa NodeAddedEvent
        class NodeRemovedEvent : public DepthSense::Event<DepthSense::Device, NodeRemovedData>
        {
            private:
            NodeRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeRemoved event object
        ///
        /// Returns a reference to the \c nodeRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeRemovedEvent& nodeRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Context DepthSense.hxx
    /// Represents an application session
    ///   
    /// The Context class represents an application session (either a
    /// standalone session or a TCP/IP client connection). A context
    /// can group a number of nodes from different devices for simultaneous
    /// monitoring of several stream data sources.
    ///
    /// Object instances obtained from a given Context instance (such
    /// as the list of devices connected to the host, or the list of
    /// nodes belonging to a specific device) are implicitly attached
    /// to that Context instance, which is then termed the object's
    /// <em>parent context</em>. Any operation performed on a device
    /// or node automatically makes use of its parent context.
    class Context
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Context (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::Audio::SampleData;
        friend class DepthSense::AudioNode;
        friend class DepthSense::Color::SampleData;
        friend class DepthSense::ColorNode;
        friend class DepthSense::Depth::IMUData;
        friend class DepthSense::Depth::SampleData;
        friend class DepthSense::Depth::ButtonEventData;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Context (const Context& other);
        DEPTHSENSE_API Context& operator= (const Context& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Context (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Context& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Context type object
        ///
        /// Returns the DepthSense::Context type object
        ///
        /// \return the DepthSense::Context type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \c localhost, port \c 6809.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(const char*), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c 6809.
        ///
        /// \param hostname the host or IP address to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname);
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c port.
        ///
        /// \param hostname the host or IP address to connect to
        /// \param port the port to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname, int32_t port);
        /// Creates a standalone DepthSense context
        ///
        /// Creates a standalone DepthSense context.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), create(const char*, int32_t)
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context createStandalone ();
        /// Runs the DepthSense event loop
        ///
        /// Runs the DepthSense event loop. The connected event
        /// handlers are run in the thread that called run().
        ///
        /// If the server throws an exception asynchronously (that is,
        /// not in reaction to a method call or property
        /// assignment/retrieval), it will be propagated to this
        /// method.
        ///
        /// To exit the event loop, call quit().
        ///
        /// \sa quit()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is already running in the current application
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::StreamingException a streaming error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::IOException a device I/O operation has failed
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void run ();
        /// Terminates the DepthSense event loop
        ///
        /// Terminates the DepthSense event loop.
        ///
        /// \sa run()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is not running in the current application
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void quit ();
        /// Starts monitoring a node
        ///   
        /// Registers a node with the current context. All registered
        /// nodes will be used as actual stream data sources.
        /// If the streaming is already started, the registered node
        /// will automatically start streaming.
        ///
        /// \param node the node to be registered
        ///
        /// \sa unregisterNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, already registered or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void registerNode (DepthSense::Node node);
        /// Stops monitoring a node
        ///    
        /// Removes the specified node from the list of monitored nodes of the
        /// current context.
        ///
        /// \param node the node to be unregistered
        ///
        /// \pre
        /// The provided node must have been subject to a prior call
        /// to registerNode().
        ///
        /// \sa registerNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset or not registered
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void unregisterNode (DepthSense::Node node);
        /// Starts the capture on the registered nodes
        ///    
        /// Starts the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa stopNodes()
        ///
        /// \exception DepthSense::ConfigurationException a valid node configuration failed to apply
        /// \exception DepthSense::StreamingException streaming could not be started
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startNodes ();
        /// Stops the capture on the registered nodes
        ///    
        /// Stops the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa startNodes()
        ///
        /// \exception DepthSense::StreamingException streaming could not be stopped
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopNodes ();
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the device is detached from the host system.
        ///
        /// \param device the device to request control of
        ///
        /// \sa requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device);
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        /// This method will try to request the control of all the nodes of the DepthSense::Device.
        /// In case of failure, none of the nodes will be controlled. When a context has the control
        /// over a DepthSense::Device, the context will be granted control on any new node added to 
        /// the DepthSense::Device.
        ///
        /// \param device the device to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device, int32_t timeout);
        /// Releases control of a device
        ///
        /// Releases full control access on \p device. If other clients/contexts
        /// are waiting for full control access on the same device or one of
        /// its nodes, control will be transferred to one of them, chosen
        /// randomly.
        ///
        /// \param device the device to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Device device);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the node is detached from the host system.
        ///
        /// \param node the node to request control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// \param node the node to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node, int32_t timeout);
        /// Releases control of a node
        ///
        /// Releases full control access on \p node. If other
        /// clients/contexts are waiting for full control access on
        /// the same node control will be transferred to one of them,
        /// chosen randomly.
        ///
        /// \param node the node to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Node node);
        /// Client-side version information
        ///
        /// The Context::getClientVersion method returns the client-side version information.
        ///
        /// \return the client-side version information
        ///
        /// \sa Context::getServerVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getClientVersion ();
        /// Server-side version information
        ///
        /// The Context::getServerVersion method returns the server-side version information.
        ///
        /// \return the server-side version information
        ///
        /// \sa Context::getClientVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getServerVersion ();
        /// The list of registered nodes
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > registeredNodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getRegisteredNodes ();
        public:
        /// Gets the value of the Context::registeredNodes property
        ///
        /// Gets the value of the Context::registeredNodes property.
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        ///
        /// \return the value of the Context::registeredNodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getRegisteredNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getRegisteredNodes().unmarshal();
            return retval;
        }
        /// The list of connected devices
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Device > devices;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Device > _p_getDevices ();
        public:
        /// Gets the value of the Context::devices property
        ///
        /// Gets the value of the Context::devices property.
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        ///
        /// \return the value of the Context::devices property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Device > getDevices ()
        {
            std::vector< DepthSense::Device > retval = _p_getDevices().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        struct ClientConnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientConnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientConnectedEvent arguments
        ///
        /// The ClientConnectedData struct holds the DepthSense::Context::ClientConnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientConnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientConnectedEvent DepthSense.hxx
        /// Event raised when a client connects
        ///   
        /// The \c clientConnected event is raised when a client connects
        /// to the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientDisconnectedEvent
        class ClientConnectedEvent : public DepthSense::Event<DepthSense::Context, ClientConnectedData_p>
        {
            private:
            ClientConnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientConnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientConnected event object
        ///
        /// Returns a reference to the \c clientConnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientConnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientConnectedEvent& clientConnectedEvent () const;
        #ifndef DEPTHSENSE_DOC
        struct ClientDisconnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientDisconnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientDisconnectedEvent arguments
        ///
        /// The ClientDisconnectedData struct holds the DepthSense::Context::ClientDisconnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientDisconnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientDisconnectedEvent DepthSense.hxx
        /// Event raised when a client disconnects
        ///   
        /// The \c clientDisconnected event is raised when a client
        /// disconnects from the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientConnectedEvent
        class ClientDisconnectedEvent : public DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>
        {
            private:
            ClientDisconnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientDisconnected event object
        ///
        /// Returns a reference to the \c clientDisconnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientDisconnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientDisconnectedEvent& clientDisconnectedEvent () const;
        /// \struct DeviceAddedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceAddedEvent arguments
        ///
        /// The DeviceAddedData struct holds the DepthSense::Context::DeviceAddedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceAddedData
        {
            /// the camera device that was attached to the host
            DepthSense::Device device;
        };
        /// \class DeviceAddedEvent DepthSense.hxx
        /// Event raised when a camera device is attached to the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// attached to the host.
        ///
        /// \param device the camera device that was attached to the host
        ///
        /// \sa DeviceRemovedEvent
        class DeviceAddedEvent : public DepthSense::Event<DepthSense::Context, DeviceAddedData>
        {
            private:
            DeviceAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceAdded event object
        ///
        /// Returns a reference to the \c deviceAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceAddedEvent& deviceAddedEvent () const;
        /// \struct DeviceRemovedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceRemovedEvent arguments
        ///
        /// The DeviceRemovedData struct holds the DepthSense::Context::DeviceRemovedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceRemovedData
        {
            /// the camera device that was detached from the host
            DepthSense::Device device;
        };
        /// \class DeviceRemovedEvent DepthSense.hxx
        /// Event raised when a camera device is detached from the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// detached from the host.
        ///
        /// \param device the camera device that was detached from the host
        ///
        /// \sa DeviceAddedEvent
        class DeviceRemovedEvent : public DepthSense::Event<DepthSense::Context, DeviceRemovedData>
        {
            private:
            DeviceRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceRemoved event object
        ///
        /// Returns a reference to the \c deviceRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceRemovedEvent& deviceRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    namespace Audio
    {
    };
    namespace Color
    {
    };
    namespace Depth
    {
        /// \class IMUData DepthSense.hxx
        /// A class holding the data retrieved from the IMU
        ///
        /// IMU data might not be available with all devices
        class IMUData
        #ifdef DEPTHSENSE_DOC
            : public DepthSense::Interface
        #endif
        {
            private:
            void* _instance;
            DEPTHSENSE_API IMUData (void* instance);
            DEPTHSENSE_API void incref ();
            DEPTHSENSE_API void decref ();
            friend class ::DSI::Marshalling;
            friend class ::DSI::CMarshalling;
            friend class DepthSense::Interface;
            friend class DepthSense::Audio::SampleData;
            friend class DepthSense::AudioNode;
            friend class DepthSense::Color::SampleData;
            friend class DepthSense::ColorNode;
            friend class DepthSense::Depth::SampleData;
            friend class DepthSense::Depth::ButtonEventData;
            friend class DepthSense::DepthNode;
            friend class DepthSense::UnsupportedNode;
            friend class DepthSense::Context;
            friend class DepthSense::Device;
            friend class DepthSense::Node;
            public:
            DEPTHSENSE_API IMUData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API IMUData (const IMUData& other);
            DEPTHSENSE_API IMUData& operator= (const IMUData& other);
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Returns the parent context
            ///
            /// Returns the context associated with the current interface.
            ///
            /// \return the parent context
            DEPTHSENSE_API DepthSense::Context getContext () const;
            #endif
            DEPTHSENSE_API ~IMUData ();
            #ifndef DEPTHSENSE_DOC
            DEPTHSENSE_API explicit IMUData (const DepthSense::Interface& iface);
            DEPTHSENSE_API bool operator== (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator!= (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator< (const DepthSense::Depth::IMUData& other) const;
            DEPTHSENSE_API bool operator> (const DepthSense::Depth::IMUData& other) const;
            #endif
            #ifndef DEPTHSENSE_DOC
            /// Checks if the current instance is set
            ///
            /// Checks if the current instance is set.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
            /// \par Example:
            /// <pre>
            /// DepthSense::AudioNode audioNode;
            /// bool b = audioNode.isSet(); // b is false
            /// </pre>
            ///
            /// \return whether the current instance is set
            DEPTHSENSE_API bool isSet () const;
            /// Unsets the current instance
            ///
            /// Unsets the current instance.
            ///
            /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
            DEPTHSENSE_API void unset ();
            /// Returns the runtime type of the current instance
            ///
            /// Returns the runtime type of the current instance.
            ///
            /// \return the runtime type of the current instance
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Type getType () const;
            #endif
            /// Returns the DepthSense::Depth::IMUData type object
            ///
            /// Returns the DepthSense::Depth::IMUData type object
            ///
            /// \return the DepthSense::Depth::IMUData type object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API static DepthSense::Type type ();
            /// Whether the data is valid or not
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API bool isValid ();
            /// The type of IMU data
            ///
            /// The IMUData::dataType property specifies the 
            /// type of IMU data received.
            #ifdef DEPTHSENSE_DOC
            @property(readonly) DepthSense::Depth::ImuDataType dataType;
            #endif
            /// Gets the value of the IMUData::dataType property
            ///
            /// Gets the value of the IMUData::dataType property.
            ///
            /// The IMUData::dataType property specifies the 
            /// type of IMU data received.
            ///
            /// \return the value of the IMUData::dataType property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Depth::ImuDataType getDataType ();
            /// The quaternion values
            #ifdef DEPTHSENSE_DOC
            @property(readonly) std::vector< float > values;
            #endif
            private:
            DEPTHSENSE_API ::DSI::Vector< float > _p_getValues ();
            public:
            /// Gets the value of the IMUData::values property
            ///
            /// Gets the value of the IMUData::values property.
            ///
            ///
            /// \return the value of the IMUData::values property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            std::vector< float > getValues ()
            {
                std::vector< float > retval = _p_getValues().unmarshal();
                return retval;
            }
            /// The last error encountered by the IMU board
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t lastError;
            #endif
            /// Gets the value of the IMUData::lastError property
            ///
            /// Gets the value of the IMUData::lastError property.
            ///
            ///
            /// \return the value of the IMUData::lastError property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getLastError ();
            /// The accuracy of the IMU data
            #ifdef DEPTHSENSE_DOC
            @property(readonly) int32_t accuracy;
            #endif
            /// Gets the value of the IMUData::accuracy property
            ///
            /// Gets the value of the IMUData::accuracy property.
            ///
            ///
            /// \return the value of the IMUData::accuracy property
            ///
            ///
            ///
            /// \exception DepthSense::TransportException a network or protocol error has occurred
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API int32_t getAccuracy ();
            #ifndef DEPTHSENSE_DOC
            /// Returns the \c propertyChanged event object
            ///
            /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
            ///
            /// \return the \c propertyChanged event object
            ///
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
            #endif
        };
    };
};
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Interface >
    {
        size_t operator() (DepthSense::Interface iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Audio::SampleData >
    {
        size_t operator() (DepthSense::Audio::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::AudioNode >
    {
        size_t operator() (DepthSense::AudioNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Color::SampleData >
    {
        size_t operator() (DepthSense::Color::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::ColorNode >
    {
        size_t operator() (DepthSense::ColorNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::IMUData >
    {
        size_t operator() (DepthSense::Depth::IMUData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::SampleData >
    {
        size_t operator() (DepthSense::Depth::SampleData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Depth::ButtonEventData >
    {
        size_t operator() (DepthSense::Depth::ButtonEventData iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::DepthNode >
    {
        size_t operator() (DepthSense::DepthNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::UnsupportedNode >
    {
        size_t operator() (DepthSense::UnsupportedNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Context >
    {
        size_t operator() (DepthSense::Context iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Device >
    {
        size_t operator() (DepthSense::Device iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Node >
    {
        size_t operator() (DepthSense::Node iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< uint8_t > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< uint8_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Audio::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Audio::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< uint64_t > >
    {
        size_t operator() (DepthSense::Property< uint64_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< int32_t > >
    {
        size_t operator() (DepthSense::Property< int32_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::AudioNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::AudioNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< float > >
    {
        size_t operator() (DepthSense::Property< float > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< bool > >
    {
        size_t operator() (DepthSense::Property< bool > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Color::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Color::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ColorNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ColorNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ExposureAuto > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ExposureAuto > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::ImuDataType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::ImuDataType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< float > > >
    {
        size_t operator() (DepthSense::Property< std::vector< float > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< int16_t > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< int16_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< float > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< float > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::Vertex > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::Vertex > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::FPVertex > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::FPVertex > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< ::DepthSense::Pointer< DepthSense::UV > > >
    {
        size_t operator() (DepthSense::Property< ::DepthSense::Pointer< DepthSense::UV > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::Acceleration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::Acceleration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::StereoCameraParameters > >
    {
        size_t operator() (DepthSense::Property< DepthSense::StereoCameraParameters > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::string > >
    {
        size_t operator() (DepthSense::Property< std::string > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::IMUData > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::IMUData > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< uint32_t > > >
    {
        size_t operator() (DepthSense::Property< std::vector< uint32_t > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::CoordinateSystemType > >
    {
        size_t operator() (DepthSense::Property< DepthSense::CoordinateSystemType > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< uint32_t > >
    {
        size_t operator() (DepthSense::Property< uint32_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Depth::ButtonID > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Depth::ButtonID > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::DepthNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::DepthNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< std::string > > >
    {
        size_t operator() (DepthSense::Property< std::vector< std::string > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Node > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Node > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Device > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Device > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Model > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Model > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Capabilities > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Capabilities > property) const;
    };
}
#endif
#endif // _DEPTHSENSE_PUBLIC_HXX
